--- 
knit: "bookdown::render_book"
title: "eBird Best Practices I"
author: "Matthew Strimas-Mackey, Alison Johnston, Wesley M. Hochachka, Viviana Ruiz-Gutierrez, Orin J. Robinson, Eliot T. Miller, Tom Auer, Steve Kelling, Daniel Fink"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
github-repo: mstrimas/ebp-workshop
description: "eBird Best Practices I: eBird Data Extraction and Processing in R"
---
```{r include=FALSE, cache=FALSE}
knitr::opts_knit$set(root.dir = here::here())
set.seed(1)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  out.width = "\\textwidth", 
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Welcome {-}

These lessons are part of a workshop given at AOS 2019 in Anchorage on eBird Best Practices. Part I of the workshop covers extracting and processing eBird data with R. The content of this workshop is also covered in the free online book [eBird Best Practices](http://strimas.com/ebird-best-practices).

<!--chapter:end:index.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r include=FALSE, cache=FALSE}
knitr::opts_knit$set(root.dir = here::here())
set.seed(1)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  out.width = "\\textwidth", 
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Introduction {#introduction}

We start with a short presentation giving and introduction to eBird and the motivation behind the `auk` package. The presentation can be [downloaded in PowerPoint format](https://github.com/mstrimas/ebp-workshop/raw/master/01_introduction.pptx) or [viewed on SpeakerDeck](https://speakerdeck.com/mstrimas/ebird-best-practices-i).

<iframe src="https://speakerdeck.com/player/8ebf7834a4c5421da9c5359782517cb6" width="700px" height="400px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:none;" allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe>

<!--chapter:end:01_introduction.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r include=FALSE, cache=FALSE}
knitr::opts_knit$set(root.dir = here::here())
set.seed(1)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  out.width = "\\textwidth", 
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Setup {#setup}

Before we dive into writing code, let's take a few minutes to ensure our systems are correctly set up with all the correct software and R packages. Devoting some time to this up front will reduce errors and make troubleshooting easier later in the workshop.

Start by opening a browser window with three tabs pointing to the following websites:

1. The [eBird homepage](https://ebird.org)
2. The [auk website](https://cornelllabofornithology.github.io/auk/). This R package is used to access eBird data and we'll be using the website to access help and resources.
3. The [etherpad](https://public.etherpad-mozilla.org/p/ebp) for this workshop. This is a collaborative notepad similar to Google Docs, which we can use to share code and links. Make sure you can edit the document.

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Are all tabs correctly opened? Can you edit the etherpad?
</div>

Next [install or update RStudio](https://www.rstudio.com/products/rstudio/download/#download), then open it up. Look at the top line of the console, which gives your R version; copy that over to the etherpad. If you have a version older than 3.5.0, [update R](https://cloud.r-project.org/). 

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Is your R version at least 3.5.0? Do you need help updating R?
</div>

Create a new RStudio project called `ebird-best-practices`. Next, install all the packages required for this workshop and part II, by running the following code:

```{r setup-install, eval = FALSE}
install.packages("remotes")
remotes::install_github("mstrimas/ebppackages")
```

As mentioned in the introduction, the `auk` package uses the unix command line tool AWK to extract data from eBird. AWK comes installed by default on Mac OS and Linux systems, but Windows users will need to install it. To do so, install the [Cygwin software](https://cygwin.com/install.html).

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Is AWK installed?
</div>

Run the following code to test that `auk` is installed correctly and AWK is working:

```{r setup-test}
library(auk)
library(tidyverse)

tf <- tempfile()
system.file("extdata/ebd-sample.txt", package = "auk") %>% 
  auk_ebd() %>%
  auk_species(species = c("Canada Jay", "Blue Jay")) %>%
  auk_country(country = c("US", "Canada")) %>%
  auk_bbox(bbox = c(-100, 37, -80, 52)) %>%
  auk_date(date = c("2012-01-01", "2012-12-31")) %>%
  auk_time(start_time = c("06:00", "09:00")) %>%
  auk_duration(duration = c(0, 60)) %>%
  auk_complete() %>% 
  auk_filter(tf) %>% 
  read_ebd() %>% 
  pull(common_name) %>% 
  message()
unlink(tf)
```

It should print `Blue Jay`.

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Did "Blue Jay" print without errors?
</div>

If you're running into any setup issues that can't be resolved, use RStudio Cloud for this workshop instead.

## Tidyverse {#setup-tidyverse}

Throughout this workshop, we'll be using functions from the Tidyverse. This is an opinionated set of packages for working with data in R. Packages such as `dplyr` and `ggplot2` are part of the Tidyverse. I'll try to explain any functions I use as they come up; however, there's one important operator from the Tidyverse that needs to be explaied up front: the pipe operator `%>%`. The pipe operator takes the expression to the left of it and "pipes" it into the first argument of the expression on the right.

```{r setup-tidyverse-pipe}
# without pipe
mean(1:10)
# with pipe
1:10 %>% mean()
```

The value of the pipe operator becomes more clean when we have several operations in a row.

```{r  setup-tidyverse-morepipe}
# without pipes
ran_norm <- rnorm(10, sd = 5)
ran_norm_pos <- abs(ran_norm)
ran_norm_sort <- sort(ran_norm_pos)
ran_norm_round <- round(ran_norm_sort, digits = 1)
ran_norm_round
# with pipes
rnorm(10, sd = 5) %>% 
  abs() %>% 
  sort() %>% 
  round(digits = 1)
```

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Any questions about the pipe?
</div>


<div class="exercise">
  <h2>Exercise</h2>
  Rewrite the following code using pipes:

```{r setup-tidyverse-ex, eval = FALSE}
round(exp(diff(log(runif(10, min = 0.5)))), 1)
```

<button class="solution">Solution</button>
<div class="solution-content">

```{r setup-tidyverse-sol}
runif(10, min = 0.5) %>% 
  log() %>% 
  exp() %>% 
  round(digits = 1)
```

</div>
</div>

<!--chapter:end:02_setup.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r include=FALSE, cache=FALSE}
knitr::opts_knit$set(root.dir = here::here())
set.seed(1)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  out.width = "\\textwidth", 
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Data Access {#access}

The complete eBird database is provided via the [eBird Basic Dataset (EBD)](https://ebird.org/science/download-ebird-data-products), a large tab-separated text file. To start working with eBird data, we need to download this file. To access the EBD, you will need to [create an eBird account](https://secure.birds.cornell.edu/cassso/account/create) and sign in to eBird. Once signed in, from the [eBird homepage](https://ebird.org/), click on the [Science tab](https://ebird.org/science) then scroll down to click on [Using eBird for science](https://ebird.org/science/download-ebird-data-products) in the right-hand menu. This page compiles links to a variety datasets, tools, and educational material for using eBird data to do science; it's a great resource!

![](assets/img/03_access_science.png)

On the following page, proceed to the eBird Basic Dataset page. If you haven't already done so, you will need to submit a request to access the EBD. You can do this after the workshop if you haven't already done so. From this page you can download the eBird Basic Dataset, a large tab-separated text file that contains (nearly) every eBird observation. In this file, each row corresponds to an observation of a species on a checklist. On this page, you can also download the Sampling Event Data. In this file, each row corresponds to a checklist rather than a species observation. We'll see why this file is important later in the workshop.

![](assets/img/03_access_ebd.png)

The EBD is huge, so **don't download these files now**. Instead, we'll be working with a small subset of the data today, which can be downloaded from the following links:

- eBird Basic Dataset: https://github.com/mstrimas/ebp-workshop/raw/master/raw-data/ebd_relApr-2019_workshop.tar
- Sampling Event Data: https://github.com/mstrimas/ebp-workshop/raw/master/raw-data/ebd_sampling_relApr-2019_workshop.tar

This subset contains data from Yucatan Peninsula (Guatemala, Belize, and five Mexican sates) from 2015-2016.

The files will be in `.tar` format, and should be unarchived. The resulting directories will contain files with extension `.txt.gz`, these files should be uncompressed (on Windows use [7-Zip](https://www.7-zip.org/), on Mac use the default system uncompression utility) to produce two text files (`ebd_relApr-2019_workshop.txt` and `ebd_sampling_relApr-2019_workshop.txt`). Move these files to a sensible, central location on your computer. When working with the full dataset, the EBD will be over 200 GB! If this is too large to fit on your computer, it can be stored on an external hard drive. We'll also talk later in the workshop about some ways of avoiding downloading the EBD.

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Are the files downloaded and unarchived into a central location?
</div>

Let's take a look at this dataset. If we were working with the full EBD, we wouldn't have enough memory to read in the whole file, but we can always read a small subset. Open a new R script (`01_ebrid-data.R`) and read in the first few lines:

```{r}
library(readr)
library(auk)

ebd_top <- read_tsv("~/data/ebird/ebd_2015-2016_yucatan.txt", n_max = 5)
```

View this data frame within RStudio. Scroll over to the `SAMPLING EVENT DATA` column and note the value: `S21914547`. With this code we can access any non-private checklist via the website by appending it to `https://ebird.org/view/checklist/`. [Look at the checklist online](https://ebird.org/view/checklist/S21914547) and compare it to the EBD. Notice three things that distiguish eBird data from other citizen science data:

1. eBird collects data on the observation process, including the survey protocol used and effort information. This facilitates more robust analyses because we can account for variation in the observation process.
2. Complete checklists enable non-detection to be inferred from the data. Without this, there's no way to distinguish whether a species was not observered or just not reported.

For these reasons, we refer to complete eBird checklists as **semi-structured** to distinguish from both most unstructured citizen science data and traditional structure scientific surveys.

<div class="exercise">
  <h2>Exercise</h2>
  Take a few minutes to explore the EBD and compare it to the checklists online.
</div>

Notice above that we had to reference the full path to the text files. In general, it's best to avoid using absolute paths in R scripts because it makes them less portable–if you're sharing the files with someone else, they'll need to change the file paths to point to the location at which they've stored the eBird data. The R package `auk` provides a workaround for this, by allowing users to set an environment variable (`EDB_PATH`) that points to the directory where you've stored the eBird data. To set this variable, use the function [`auk_set_ebd_path()`](https://cornelllabofornithology.github.io/auk/reference/auk_set_ebd_path.html). For example, if the EBD and Sampling Event Data files are in `~/data/ebird/`, use:

```{r eval = FALSE}
auk_set_ebd_path("~/data/ebird/")
```

The function `auk_ebd()` creates an R object referencing the EBD text file. Now that we've set up an EBD path, we can reference the EBD directly within `auk_ebd()` even though it's not in our working directory.

```{r}
auk_ebd("ebd_2015-2016_yucatan.txt")
```

You should now see the EBD text file referenced as `Input` in this `auk_ebd` object. The remainder of the information printed will be the topic of the next section.

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Were you able to create an `auk_ebd` object from the EBD text?
</div>

<!--chapter:end:03_access.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r include=FALSE, cache=FALSE}
knitr::opts_knit$set(root.dir = here::here())
set.seed(1)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  out.width = "\\textwidth", 
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Filtering {#filter}

The EBD is huge, much too large to be read into R. So, if we want to work with these data, we first need to extract a small enough subset that it can be processed by R. This is the main purpose of the `auk` package: it uses the unix command line utility AWK to extract data from the EBD. There are three steps to this filtering process:

1. Set up a reference to the EBD text file with `auk_ebd()`.
2. Define a set of filters.
3. Compile those filters into an AWK script and run it.

<div class="tip">
  <h2>Tip</h2>
  Filtering with `auk` can be fairly coarse, we just need to make the data small enough to read into R. Once the data are in R, they can be further subset.
</div>

## Defining filters {#filter-define}

The types of filters that can be applied to the EBD fall into four categories:

- **Species**
- **Region**
- **Season**
- **Protocol** and effort

Each specific filter is implemented by a different function in `auk`. Visit the [documentation on filters](https://cornelllabofornithology.github.io/auk/reference/index.html#section-filter) on the `auk` website for a complete list. Each of these functions defines a filter on a column within the EBD. For example, `auk_country()` will define a filter allowing us to extract data from a subset of countries from the EBD.

To define a filter, start by creating an `auk_ebd` object, then pipe this into one of the filtering functions.

```{r filter-country}
library(auk)

auk_ebd("ebd_2015-2016_yucatan.txt") %>% 
  auk_country("Guatemala")
```

Notice that when the `auk_ebd` object is printed, it tells us what filters have been defined. At this point, nothing has been done to the EBD, we've just *defined* the filter, we haven't executed it yet. 

In general, you should think about filtering on region, season, and species, so let's build upon what we already have and add some more filters. For example, if we wanted all Resplendant Quetzal records from Guatemala in June 2015 we would use the following filters:

```{r filter-quetzal}
auk_ebd("ebd_2015-2016_yucatan.txt") %>% 
  auk_species("Resplendent Quetzal") %>% 
  auk_country("Guatemala") %>% 
  auk_date(c("2015-06-01", "2015-06-30"))
```

<div class="tip">
  <h2>Tip</h2>
  The filtering functions in `auk` check the arguments you provide and will throw an error if there's something wrong. Filtering the EBD takes a long time, so it's better to get an error now rather than realizing you made a mistake after waiting several hours for the extraction process to complete.
  
```{r fitler-errors, error=TRUE}
auk_ebd("ebd_2015-2016_yucatan.txt") %>% 
  auk_species("Resplendant Quetzal")

auk_ebd("ebd_2015-2016_yucatan.txt") %>% 
  auk_date(c("2016-06-01", "2015-06-30"))
```
  
</div>

<div class="exercise">
  <h2>Exercise</h2>
  Define filters to extract Magnolia Warbler observations from Belize that are from checklists that started between 5 and 9 am and used either the Traveling or Stationary protocols. Consult the list of filters to see which ones you'll need to use.
  
  <button class="solution">Solution</button>
<div class="solution-content">

```{r filter-define-sol}
auk_ebd("ebd_2015-2016_yucatan.txt") %>% 
  auk_species("Magnolia Warbler") %>% 
  auk_country("BZ") %>% 
  auk_protocol(c("Traveling", "Stationary")) %>% 
  auk_time(c("5:00", "9:00"))
```

</div>
</div>

<div class="tip">
  <h2>Tip</h2>
  In general, when using the effort filters like `auk_time()` or `auk_distance()`, it's best to be quite coarse. You can always refine the filters later once the data are in R and starting with a coarse filter gives you some wiggle room if you later realize you want to make adjustments. Remember: **the initial filtering with `auk` takes a long time**, it's best to limit the number of times you do this.
</div>

When filtering by date, you may need to extract records from a given date range *regardless of year*. For the situation, the `auk_date()` function can accept wildcards for the year. For example, we can rewrite the above Resplendent Quetzal example to get observations from June of any year.

```{r filter-define-wildcards}
auk_ebd("ebd_2015-2016_yucatan.txt") %>% 
  auk_species("Resplendent Quetzal") %>% 
  auk_country("Guatemala") %>% 
  auk_date(c("*-06-01", "*-06-30"))
```

### Complete checklists {#filter-define-complete}

One of the most important filters is `auk_complete()`, which limits observations to those from complete checklists. As we've already seen, with complete checklists we can infer non-detections from the data. For most scientific applications, it's critical that we have complete checklists, so we can generate presence/absence data.

<div class="exercise">
  <h2>Exercise</h2>
  Define filters to extract Horned Guan and Highland Guan records from complete checklists in Chiapas, Mexico. Hint: you should use the `auk_state()` filter.
  
  <button class="solution">Solution</button>
<div class="solution-content">

```{r filter-define-complete-sol}
auk_ebd("ebd_2015-2016_yucatan.txt") %>% 
  auk_species(c("Horned Guan", "Highland Guan")) %>% 
  auk_state("MX-CHP") %>% 
  auk_complete()
```

</div>
</div>

<div class="tip">
  <h2>Tip</h2>
  To find the state code, consult the `ebird_states` data frame or visit the [Explore page](https://ebird.org/explore) on the eBird website and enter the state name under Explore Region. The state code will appear after `region` in the URL. For example, for Chiapas the URL is `https://ebird.org/region/MX-CHP?yr=all` and the state code is therefore `MX-CHP`.
</div>

## Execute filters {#filter-execute}

Once you have an `auk_ebd` object with a set of filters defined you can execute those filters with `auk_filter()`. This function compiles the filters into an AWK script, then executes that script to produce a text file with the defined subset of the EBD. We'll store this output file within the `data/` subdirectory of the project directory. Note that **filtering on the full EBD will take at least a couple hours**, so be prepared to wait awhile.

```{r filter-execute}
ebd_filtered <- auk_ebd("ebd_2015-2016_yucatan.txt") %>% 
  auk_species("Yellow-rumped Warbler") %>% 
  auk_country("GT") %>% 
  auk_protocol(c("Traveling", "Stationary")) %>% 
  auk_complete() %>% 
  auk_filter(file = "data/ebd_yerwar.txt")
ebd_filtered
```

Notice that we've drastically reduced the size of the file and it can now be imported into R without any issues.

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Any questions on filtering?
</div>

<!--chapter:end:04_filter.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r include=FALSE, cache=FALSE}
knitr::opts_knit$set(root.dir = here::here())
set.seed(1)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  out.width = "\\textwidth", 
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Importing Data {#import}

In the previous lesson we extracted a subset of the EBD containing Yellow-rumped Warbler observations from Guatemala. The output file created by `auk_filter()` is a tab-seperated text file and could be read into using `read.delim()` or `readr::read_tsv()`; however, `auk` has a function specifically for reading the EBD. `read_ebd()` does the following:

1. Reads the data using `data.table::fread()`, which is much faster than `read.delim()`.
2. Sets the correct variable types.
3. Cleans up the column names so they are all `snake_case`.
4. Automatically performs some post processing steps, which will be covered later in this lesson.

Let's read in the data!

```{r import-read}
library(auk)
library(dplyr)

ebd <- read_ebd("data/ebd_yerwar.txt", unique = FALSE, rollup = FALSE)
glimpse(ebd)
```

We'll cover the use of `unique = FALSE` and `rollup = FALSE` next. For now, let's just look at the data.

<div class="exercise">
  <h2>Exercise</h2>
  Take a minute to explore these data using `glimpse()` and `View()`. Familiarize yourself with the columns.
</div>

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Do you have the data in a data frame? Does anyone have any questions about the data so far?
</div>

## Group checklists {#import-group}

eBird allows users to share checklists with other eBird users that they're birding with. This results it multiple copies of some checklists in the database. Group checklists can be identified in the data because they have the `group_identifier` populated. Let's take a look at these checklists.

```{r import-group-view}
filter(ebd, !is.na(group_identifier)) %>% 
  select(sampling_event_identifier, group_identifier) %>% 
  head()
```

We see that there are multiple checklists with the same `group_identifier`, implying that these checklists have been shared and are duplicates. Let's look at one of these on the eBird website: https://ebird.org/view/checklist/S26466410

As it turns out, group checklists aren't exact duplicates; once a checklist has been shared the individual checklists can diverge in terms of the species seen, the counts for each species, and even the protocol and effort.

In most cases, you'll only want to retain one of these checklists, but it's not trivial to do so because the checklists are only partial duplicates. The function `auk_unique()` manages this for you. Specifically, for each species, it retains only the first observation of that species, which is typically the one submitted by the primary observer (i.e. the person who recorded the original checklist).

```{r import-group-fix}
keep_one <- filter(ebd, group_identifier == "G1480977") %>% 
  auk_unique()
```

Note that a new field has been created (`checklist_id`), which is populated with `group_identifier` for group checklists and `sampling_event_identifier` otherwise; this is now a unique identifier for checklists. In addition, the full set of observer and sampling event identifiers has been retained in a comma seperated format.

By default, `read_ebd()` calls `auk_unique()` automatically; however, this behaviour can be controlled with the `unique` argument.

```{r import-group-read}
ebd <- read_ebd("data/ebd_yerwar.txt", rollup = FALSE)
```

<div class="tip">
  <h2>Tip</h2>
  `auk_unique()` takes a long time to run on large datasets. Consider using `read_ebd(unique = FALSE)` when importing large text files to prevent R from freezing.
</div>

## Taxonomy {#import-taxonomy}

eBird users can enter data for a wide range of taxa in addition to species. Observations can be reported at a level more granular than species (e.g. subspecies or recognizable forms) or at a higher level than species (e.g. spuhs, slashes, and hybrids). All the different taxa that can be reported are contains in the eBird taxonomy, which is updated every year in August. The eBird Science page has a [subsection with details on the eBir](https://ebird.org/science/the-ebird-taxonomy) taxonomy and the taxonomy itself is available in the package as a dataframe in the `auk` package.

```{r import-taxonomy-taxdf}
glimpse(ebird_taxonomy)
```

Note that for taxa below the species level, the `report_as` field specifies the species that this taxa falls under. The EBD contains a subspecies column which is populated when an observer has identified a bird below species level. In the EBD extract we're working with, we have three different subspecies of Yellow-rumped Warbler:

```{r import-taxonomy-yerwar}
count(ebd, common_name, subspecies_common_name)
```

It's even possible to have multiple subspecies of the same species on a single checklist.

```{r import-taxonomy-multiple}
filter(ebd, checklist_id == "S22725024") %>% 
  select(checklist_id, common_name, subspecies_common_name, observation_count)
```

For most uses, you'll want eBird data at the species level, which means dropping higher level taxa and rolling lower level taxa up to species level, making sure to sum the counts if multiple subspecies were present. The function `auk_rollup()` handles these taxonomic matters for you.

```{r import-taxonomy-rollup}
no_subsp <- auk_rollup(ebd)
filter(no_subsp, checklist_id == "S22725024") %>% 
  select(checklist_id, common_name, observation_count)
```

By default, `read_ebd()` calls `auk_rollup()` automatically; however, this behaviour can be controlled with the `rollup` argument.

```{r import-group}
ebd <- read_ebd("data/ebd_yerwar.txt")
```

<div class="checkpoint">
  <h2>Checkpoint</h2>
  Any questions on data import, taxonomy, or group checklists?
</div>

<!--chapter:end:05_import.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r include=FALSE, cache=FALSE}
knitr::opts_knit$set(root.dir = here::here())
set.seed(1)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  out.width = "\\textwidth", 
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Presence-absence Data {#presabs}

Up to this point we've been working with presence-only data. The EBD, and eBird checklist in general, only explicitly record positive observations of species. However, if we limit ourselves to complete checklists, we can fill in the implied zero counts for any checklists on which a given species isn't explicitly reported to presence-absence data. We refer to this process as **zero-filling** the eBird data.

Zero-filling relies on the Sampling Event Data, which is a tab-seperated text file containing checklist-level information. This file contains the full population of checklists in the eBird database. If we apply exactly the same set of filters to both the EBD and the Sampling Event Data we can assume that any checklist with no observations for a given species in the EBD should get a zero-count record added to the dataset. So, producing Presence-absence eBird data is a two-step process:

1. Simultaneously filter the EBD and Sampling Event Data, making sure to only use complete checklists.
2. Read both files into R and zero-fill the EBD using the full population of checklists from the Sampling Event Data.

<div class="tip">
  <h2>Tip</h2>
  When we say "presence-absence" what we really mean by absence is that the species was not detected, it's entirely possible that the species was presented but the observer didn't detect it.
</div>

## Filtering {#presabs-filter}

Simultaneously filtering the EBD and Sampling Event Data is done in almost the exact same way as filtering the EBD alone. The only difference is that we provide both files to `auk_ebd()` and two corresponding output files to `auk_filter()`. For example, we can extract all American Flamingo observations from January in the Mexican state of Yucatán in preparation for zero-filling:

```{r presabs-filter}
library(auk)
library(dplyr)

f_ebd <- "data/ebd_amefla.txt"
f_sed <- "data/sed_amefla.txt"
ebd_filt <- auk_ebd("ebd_2015-2016_yucatan.txt", 
                    file_sampling = "ebd_sampling_2015-2016_yucatan.txt") %>% 
  auk_species("American Flamingo") %>% 
  auk_state("MX-YUC") %>% 
  auk_date(c("*-01-01", "*-01-31")) %>% 
  auk_complete() %>% 
  auk_filter(f_ebd, file_sampling = f_sed)
```

We now have two output files that have been extract using the same set of filters, apart from the species filter, which only applies to the EBD. We can read these files into R individually:

```{r presabs-filter-read}
ebd_only <- read_ebd(f_ebd)
sed_only <- read_sampling(f_sed)
n_distinct(ebd_only$checklist_id)
n_distinct(sed_only$checklist_id)
```

So, we have `r n_distinct(sed_only$checklist_id)` checklists in the Sampling Event Data and, of those, `r n_distinct(ebd_only$checklist_id)` have Ocellated Turkey observations on them.

<div class="exercise">
  <h2>Exercise</h2>
  You're studying Hooded Warblers wintering (November-February) in Belize. Extract eBird data in preparation for zero-filling, then read in the results and explore them. Hint: consult the Details section of the documentation for `auk_date()` to see how to filter a range of dates that wrap around the year end.
  
  <button class="solution">Solution</button>
<div class="solution-content">

```{r presabs-filter-sol}
f_ebd_hw <- "data/ebd_hoowar.txt"
f_sed_hw <- "data/sed_hoowar.txt"
ebd_filt <- auk_ebd("ebd_2015-2016_yucatan.txt", 
                    file_sampling = "ebd_sampling_2015-2016_yucatan.txt") %>% 
  auk_species("Hooded Warbler") %>% 
  auk_country("BZ") %>% 
  # when using wildcards, dates can wrap around the year end
  auk_date(c("*-11-01", "*-02-29")) %>% 
  auk_complete() %>% 
  auk_filter(f_ebd_hw, file_sampling = f_sed_hw)
# import the data
ebd_only_hw <- read_ebd(f_ebd_hw)
sed_only_hw <- read_sampling(f_sed_hw)
```

</div>
</div>

## Zero-filling {#presabs-zerofill}

Now that we have these two datasets, containing checklist and species information, we can use the function `auk_zerofill()` to combine them to produce presence-absence data. This function also imports the data and handles group checklists and taxonomic rollup automatically, we just have to pass it the paths to the two files. Let's do this with the American Flamingo data.

```{r presabs-zerofill}
ebd_zf <- auk_zerofill(f_ebd, sampling_events = f_sed)
ebd_zf
```

By default, `auk_zerofill()` returns the data as a list of two dataframes: `sampling_events` contains all the checklist and `observations` contains just the counts and presence-absence data for each species on each checklist. This compact format reduces the size of the data because checklist information isn't replicated for every species observation.

```{r presabs-zerofill-components}
glimpse(ebd_zf$observations)
glimpse(ebd_zf$sampling_events)
```

However, in this case object size isn't an issue, and it's easier to work with a single dataframe, so we can collapse the data with:

```{r presabs-zerofill-collapse}
ebd_zf_df <- collapse_zerofill(ebd_zf)
glimpse(ebd_zf_df)
```

Notice that in addition to the `observation_count` column, we now have a binary `species_observered` column specifying whether or not the species was observered on this checklist. You can also automatically collapse the data by using the `collapse = TRUE` argument to `auk_zerofill()`.

<div class="exercise">
  <h2>Exercise</h2>
  Zero-fill and collapse the Hooded Warbler data you extracted in the previous exercise.
  
  <button class="solution">Solution</button>
<div class="solution-content">

```{r presabs-zerofill-sol}
ebd_zf_hw <- auk_zerofill(f_ebd_hw, f_sed_hw)
```

</div>
</div>

<div class="tip">
  <h2>Tip</h2>
  Whenever you're zero-filling data it's critical that you think about region and season (i.e. where and when) in addition to just the species. If you don't do that, you'll zero-fill the entire global EBD and your computer will explode. For example, consider a highly localized species like the [Cozumel Vireo](https://ebird.org/species/cozvir1), endemic to the small island of Cozumel off the coast of Mexico. Let's try just filtering on species.
  
```{r presabs-zerofill-cozwir}
ebd_cozvir <- auk_ebd("ebd_2015-2016_yucatan.txt", 
                    file_sampling = "ebd_sampling_2015-2016_yucatan.txt") %>% 
  auk_species("Cozumel Vireo") %>% 
  auk_complete() %>% 
  auk_filter("data/ebd_cozvir.txt", "data/sed_cozvir.txt") %>% 
  auk_zerofill(collapse = TRUE)
table(ebd_cozvir$species_observed)
```

What we have here is the entire EBD (36 million checklists!) for a species that only occurs on one small island. In this situation, you would be better to identify the boundaries of the island and use `auk_bbox()` to spatially subset the data.

```{r presabs-zerofill-cozwir-bbox}
ebd_cozvir <- auk_ebd("ebd_2015-2016_yucatan.txt", 
                      file_sampling = "ebd_sampling_2015-2016_yucatan.txt") %>% 
  auk_species("Cozumel Vireo") %>% 
  # lng_min, lat_min, lng_max, lat_max
  auk_bbox(c(-87.12, 20.25, -86.68, 20.63)) %>% 
  auk_complete() %>% 
  auk_filter("data/ebd_cozvir.txt", "data/sed_cozvir.txt", overwrite = TRUE) %>% 
  auk_zerofill(collapse = TRUE)
table(ebd_cozvir$species_observed)
```

We have the same number of positive observations, but have now drastically reduced the number of checklists without Cozumel Vireo observations.

</div>

## Tidying up {#presabs-tidy}

We now have a zero-filled presence-absence dataset with duplicate group checklists removed and all observations at the species level. There are couple remaining steps that we typically run to clean up the data. First, you may have noticed some cases where `observation_count` is `"X"` in the data. This is what eBirders enter for the count to indicate that they didn't count the number of individuals for a given species. 

```{r zerofill-tidy-x}
arrange(ebd_zf_df, desc(observation_count)) %>% 
  select(checklist_id, observation_count) %>% 
  head(10)
```

It's more appropriate to have this as `NA` rather than `"X"` and this will also allow us to convert the count column data type to integer rather than character. At this point, we'll also assign an explicit distance of 0 to stationary checklists.

```{r presabs-tidy-na}
zf_count <- ebd_zf_df %>% 
  mutate(observation_count = if_else(observation_count == "X", 
                                     NA_character_, observation_count),
         observation_count = as.integer(observation_count),
         effort_distance_km = if_else(protocol_type == "Stationary", 
                                      0, effort_distance_km))
```

Finally, depending on your application, you'll likely want to do some further filtering of the data. For many uses, it's a good idea to reduce the variation in detectability between checklists by imposing some constraints on the effort variables. For example, in part II of this workshop, we'll restrict observations to those from checklists less than 5 hours long and 5 km in length, and with 10 or fewer observers.

```{r presabs-tidy-effort}
zf_effort <- zf_count %>% 
  filter(duration_minutes <= 60 * 5,
         effort_distance_km <= 5,
         number_observers <= 10)
table(zf_count$species_observed)
table(zf_effort$species_observed)
```

We've reduced the amount of data, but also decreased the variability in effort, which will lead to better model performance if we use these data to model species distributions.

<!--chapter:end:06_presabs.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r include=FALSE, cache=FALSE}
knitr::opts_knit$set(root.dir = here::here())
set.seed(1)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  out.width = "\\textwidth", 
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Applications {#applications}

Now that we know how to extract and zero-fill data from eBird, let's do something with these data! We'll start by summarizing the data to show the trajectory of observation frequency over the course of the year. Next, we'll make a basic presence-absence map of eBird observations. More advanced topics are covered in part II of this workshop, which focuses on using eBird data to model species distributions.

## Frequency trajectories {#applications-trajectory}

The genus *Cardellina* contains five New World warbler species, including some of the most spectacular birds in North America: [Canada Warbler](https://ebird.org/species/canwar/), [Red Warbler](https://ebird.org/species/redwar1/), and [Pink-headed Warbler](https://ebird.org/species/pihwar1/). Let's extract and zero-fill data for these three species in this genus within Guatemala.

```{r applications-trajectory-extract}
library(auk)
library(sf)
library(rnaturalearth)
library(lubridate)
library(tidyverse)

f_ebd <- "data/ebd_cardellina.txt"
f_sed <- "data/sed_cardellina.txt"

# extract
filters <- auk_ebd("ebd_2015-2016_yucatan.txt", 
                   file_sampling = "ebd_sampling_2015-2016_yucatan.txt") %>% 
  auk_species(c("Canada Warbler", "Wilson's Warbler", 
                "Pink-headed Warbler")) %>% 
  auk_country("Guatemala") %>% 
  auk_complete() %>% 
  auk_filter(f_ebd, f_sed)

# zero-fill
cardellina_zf <- auk_zerofill(f_ebd, f_sed, collapse = TRUE)
count(cardellina_zf, scientific_name, species_observed)
```

Next, let's summarize these data, calculating the frequency of observation on eBird checklists by month.

```{r applications-trajectory-summarize}
cardellina_freq <- cardellina_zf %>% 
  mutate(month = month(observation_date)) %>% 
  group_by(scientific_name, month) %>% 
  summarize(obs_freq = mean(species_observed)) %>% 
  ungroup()
```

In prepartion for plotting, we can add the common names of the species by joining in the `ebird_taxonomy` data frame, which is included with `auk`. In addition, we'll convert the integer month numbers to dates–using the midpoint of each month–to aid axis labelling.

```{r  applications-trajectory-common}
cardellina_comm <- cardellina_freq %>% 
  inner_join(ebird_taxonomy, by = "scientific_name") %>% 
  select(common_name, month, obs_freq) %>% 
  mutate(month_midpoint = ymd(str_glue("2019-{month}-15")))
```

Finally, let's make a frequency trajectory for these four species.

```{r applications-trajectory-plot}
ggplot(cardellina_comm) +
  aes(x = month_midpoint, y = obs_freq, color = common_name) +
  geom_point() +
  geom_line() +
  scale_x_date(date_breaks = "2 months",
               date_labels = "%b") +
  scale_color_brewer(palette = "Set1") +
  labs(x = "Month", y = "Observation Frequency",
       color = NULL) +
  theme(legend.position = "bottom")
```

We have several different patterns going on here:

- Pink-headed Warblers is resident species, present year-round at fairly low abundance
- Wilson's Warbler is a migrant, spending the winter in Guatemala and is common during that period
- Canada Warbler appears to only pass through Guatemala during migration

## Maps {#applications-maps}

Continuing with the same dataset, let's make a presence-absence map for Pink-headed Warbler. Let's start by filtering the zero-filled data to only Pink-headed Warbler observations and converting these points to a spatial format using the `sf` package.

```{r applications-maps-sf}
pihwar <- cardellina_zf %>% 
  filter(scientific_name == "Cardellina versicolor") %>% 
  mutate(pres_abs = if_else(species_observed, "Present", "Not detected")) %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
```

Next, we'll use `rnaturalearth` to get some contextual GIS data to use in our maps. This is an amazing source for free GIS data for making maps.

```{r applications-maps-rne}
ne_country <- ne_countries(continent = "North America", returnclass = "sf") %>% 
  st_geometry()
ne_gt <- ne_countries(country = "Guatemala", returnclass = "sf") %>% 
  st_geometry()
# restrict to points falling within Guatemala, removes those over water
pihwar <- pihwar[ne_gt, ]
```

Finally, we'll make a presence-absence map, building it up in layers. There are lots excellent tools for mapping in R; however, here we'll use the basic `plot()` function from the `sf` package.

```{r applications-maps-map}
par(mar = c(0.25, 0.25, 0.25, 0.25))
plot(ne_gt, col = NA, border = NA)
plot(ne_country, col = "grey80", border = "white", add = TRUE)
plot(ne_gt, col = "grey70", border = "white", add = TRUE)
# not observed
pihwar_abs <- filter(pihwar, !species_observed) %>% 
  st_geometry()
plot(pihwar_abs, col = alpha("grey20", 0.3), pch = 19, cex = 0.25, add = TRUE)
# present
pihwar_pres <- filter(pihwar, species_observed) %>% 
  st_geometry()
plot(pihwar_pres, col = alpha("orange", 1), pch = 19, cex = 0.5, add = TRUE)
title("Pink-headed Warbler eBird Observations", line = -1)
legend("bottomright", 
       col = c("grey20", "orange"),
       legend = c("Not reported", "Present"),
       pch = 19)
box()
```

Within Guatemala, Pink-headed Warbler is restricted to the southwestern highlands of Guatemala.

<div class="exercise">
  <h2>Exercise</h2>
  Make a similar map of Wilson's Warbler (*Cardellina pusilla*) observations.
  
  <button class="solution">Solution</button>
<div class="solution-content">

```{r applications-maps-sol}
# prepare data
wilwar <- cardellina_zf %>% 
  filter(scientific_name == "Cardellina pusilla") %>% 
  mutate(pres_abs = if_else(species_observed, "Present", "Not detected")) %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
wilwar <- wilwar[ne_gt, ]

# make map
par(mar = c(0.25, 0.25, 0.25, 0.25))
plot(ne_gt, col = NA, border = NA)
plot(ne_country, col = "grey80", border = "white", add = TRUE)
plot(ne_gt, col = "grey70", border = "white", add = TRUE)
# not observed
wilwar_abs <- filter(wilwar, !species_observed) %>% 
  st_geometry()
plot(wilwar_abs, col = alpha("grey20", 0.3), pch = 19, cex = 0.25, add = TRUE)
# present
wilwar_pres <- filter(wilwar, species_observed) %>% 
  st_geometry()
plot(wilwar_pres, col = alpha("orange", 1), pch = 19, cex = 0.5, add = TRUE)
title("Wilson's Warbler eBird Observations", line = -1)
legend("bottomright", 
       col = c("grey20", "orange"),
       legend = c("Not reported", "Present"),
       pch = 19)
box()
```

</div>
</div>

<!--chapter:end:07_applications.Rmd-->

---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r include=FALSE, cache=FALSE}
knitr::opts_knit$set(root.dir = here::here())
set.seed(1)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  out.width = "\\textwidth", 
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)
options(dplyr.print_min = 6, dplyr.print_max = 6)
```

# Advanced Topics {#advanced}

## Custom downloads {#advanced-custom}

## Preparing for occupancy modeling {#advanced-unmarked}

## Land cover covariates {#advanced-modis}

## Dealing with multiple species {#advanced-multi}

## Reducing file size {#advanced-size}



```{r cleanup, echo = FALSE}
unlink(list.files("data/", full.names = TRUE))
```



<!--chapter:end:08_advanced.Rmd-->

