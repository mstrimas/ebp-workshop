[
["index.html", "eBird Best Practices I Welcome", " eBird Best Practices I Matthew Strimas-Mackey, Alison Johnston, Wesley M. Hochachka, Viviana Ruiz-Gutierrez, Orin J. Robinson, Eliot T. Miller, Tom Auer, Steve Kelling, Daniel Fink 2019-06-22 Welcome These lessons comprise Part I of a workshop on best practices for using eBird data. This workshop covers extracting and processing eBird data with R, while Part II of the workshop covers using these data to model species distributions. The content of this workshop is also covered in the free online book eBird Best Practices. "],
["introduction.html", "Lesson 1 Introduction", " Lesson 1 Introduction We start with a short presentation giving an introduction to eBird and the motivation behind the auk R package. The presentation can be downloaded in PowerPoint format or viewed on SpeakerDeck. "],
["setup.html", "Lesson 2 Setup 2.1 Tidyverse", " Lesson 2 Setup Before we dive into writing code, let’s take a few minutes to ensure our systems are properly set up with all the correct software and R packages. Devoting some time to this up front will reduce errors and make troubleshooting easier later in the workshop. Start by opening a browser window with four tabs pointing to the following websites: The shared Google Doc for this workshop. This is a will act as a collaborative notepad, which we can use to share code and links. Make sure you can edit the document. The eBird homepage The auk website. This R package is used to access eBird data and we’ll be using the website to access help and resources. The online lessons for this workshop. Checkpoint Are all tabs correctly opened? Can you edit the etherpad? Next install or update RStudio, then open it up. Look at the top line of the console, which gives your R version; copy that over to the Google Doc If you have a version older than 3.5.0, consider updating R. Checkpoint Is your R version at least 3.5.0? Do you need help updating R? Create a new RStudio project called ebird-best-practices. Next, install all the packages required for this workshop and part II, by running the following code: install.packages(&quot;remotes&quot;) remotes::install_github(&quot;mstrimas/ebppackages&quot;) As mentioned in the introduction, the auk package uses the unix command line tool AWK to extract data from eBird. AWK comes installed by default on Mac OS and Linux systems, but Windows users will need to install it. To do so, install the Cygwin software. Checkpoint Is AWK installed? Run the following code to test that auk is installed correctly and AWK is working: library(auk) library(tidyverse) tf &lt;- tempfile() system.file(&quot;extdata/ebd-sample.txt&quot;, package = &quot;auk&quot;) %&gt;% auk_ebd() %&gt;% auk_species(species = c(&quot;Canada Jay&quot;, &quot;Blue Jay&quot;)) %&gt;% auk_country(country = c(&quot;US&quot;, &quot;Canada&quot;)) %&gt;% auk_bbox(bbox = c(-100, 37, -80, 52)) %&gt;% auk_date(date = c(&quot;2012-01-01&quot;, &quot;2012-12-31&quot;)) %&gt;% auk_time(start_time = c(&quot;06:00&quot;, &quot;09:00&quot;)) %&gt;% auk_duration(duration = c(0, 60)) %&gt;% auk_complete() %&gt;% auk_filter(tf) %&gt;% read_ebd() %&gt;% pull(common_name) %&gt;% message() unlink(tf) It should print Blue Jay. Checkpoint Did “Blue Jay” print without errors? If you’re running into any setup issues that can’t be resolved, use RStudio Cloud for this workshop instead. 2.1 Tidyverse Throughout this workshop, we’ll be using functions from the Tidyverse. This is an opinionated set of packages for working with data in R. Packages such as dplyr, ggplot2, and purrr are part of the Tidyverse. We’ll try to explain any functions as they come up; however, there’s one important operator from the Tidyverse that needs to be explained up front: the pipe operator %&gt;%. The pipe operator takes the expression to the left of it and “pipes” it into the first argument of the expression on the right. # without pipe mean(1:10) #&gt; [1] 5.5 # with pipe 1:10 %&gt;% mean() #&gt; [1] 5.5 The value of the pipe operator becomes clear when we have several operations in a row. Using the pipe makes code easier to read and reduces the need for intermediate variables. # without pipes set.seed(1) ran_norm &lt;- rnorm(10, sd = 5) ran_norm_pos &lt;- abs(ran_norm) ran_norm_sort &lt;- sort(ran_norm_pos) ran_norm_round &lt;- round(ran_norm_sort, digits = 1) ran_norm_round #&gt; [1] 0.9 1.5 1.6 2.4 2.9 3.1 3.7 4.1 4.2 8.0 # with pipes set.seed(1) rnorm(10, sd = 5) %&gt;% abs() %&gt;% sort() %&gt;% round(digits = 1) #&gt; [1] 0.9 1.5 1.6 2.4 2.9 3.1 3.7 4.1 4.2 8.0 For those that have never used the pipe, it probably looks strange, but if you stick with it, you’ll quickly come to appreciate it. Checkpoint Any questions about the pipe? Exercise Rewrite the following code using pipes: set.seed(1) round(exp(diff(log(runif(10, min = 0.5)))), 1) Solution set.seed(1) runif(10, min = 0.5) %&gt;% log() %&gt;% diff() %&gt;% exp() %&gt;% round(digits = 1) #&gt; [1] 1.1 1.1 1.2 0.6 1.6 1.0 0.9 1.0 0.7 "],
["access.html", "Lesson 3 Data Access", " Lesson 3 Data Access The complete eBird database (with the exception of sensitive species and observations that haven’t been approved) is provided via the eBird Basic Dataset (EBD), a large tab-separated text file released monthly. To start working with eBird data, we need to download this file. To access the EBD, you will need to create an eBird account and sign in to eBird. Once signed in, from the eBird homepage, click on the Science tab then scroll down to click on Using eBird for science in the right-hand menu. This page compiles links to a variety datasets, tools, and educational material for using eBird data to do science; it’s a great resource! CLick on the “Download raw data here” link, then proceed to the eBird Basic Dataset page. If you haven’t already done so, you will need to submit a request to access the EBD. You can do this after the workshop if you haven’t already, we won’t need access today. From this page you can download the eBird Basic Dataset, a large tab-separated text file that contains (nearly) every eBird observation. In this file, each row corresponds to an observation of a species on a checklist. On this page, you can also download the Sampling Event Data. In this file, each row corresponds to a checklist rather than a species observation. We’ll see why this file is important later in the workshop. The EBD is huge, so don’t download these files now. Instead, we’ll be working with a small subset of the data today, which can be downloaded from the following links: eBird Basic Dataset: https://github.com/mstrimas/ebp-workshop/raw/master/raw-data/ebd_2015-2016_yucatan.tar Sampling Event Data: https://github.com/mstrimas/ebp-workshop/raw/master/raw-data/ebd_sampling_2015-2016_yucatan.tar This subset contains data from Yucatan Peninsula (Guatemala, Belize, and five Mexican sates) from 2015-2016. The files will be in .tar format, and you should be unarchive them (this may require 7-Zip on Windows). The resulting directories will contain files with extension .txt.gz, these files should be uncompressed to produce two text files (ebd__2015-2016_yucatan.txt and ebd_sampling_2015-2016_yucatan.txt). Move these files to a sensible, central location on your computer. When working with the full dataset, the EBD will be over 200 GB! If this is too large to fit on your computer, it can be stored on an external hard drive. We’ll also talk later in the workshop about some ways of avoiding downloading the EBD. Checkpoint Are the files downloaded and unarchived into a central location? Let’s take a look at this dataset. If we were working with the full EBD, we wouldn’t have enough memory to read in the whole file, but we can always read a small subset. Open a new R script (01_ebird-data.R) and read in the first few lines: library(readr) library(auk) ebd_top &lt;- read_tsv(&quot;~/data/ebird/ebd_2015-2016_yucatan.txt&quot;, n_max = 5) View this dataframe within RStudio. Scroll over to the SAMPLING EVENT DATA column, which uniquely identifies checklists, and note the value: S21914547. With this ID we can access any non-private checklist via the website by appending it to https://ebird.org/view/checklist/. Look at the checklist online and compare it to the EBD. Notice two things that distiguish eBird data from other citizen science data: eBird collects data on the observation process, including the survey protocol used and effort information. This facilitates more robust analyses because we can account for variation in the observation process. Complete checklists enable non-detection to be inferred from the data. Without this, there’s no way to distinguish whether a species was not observered or just not reported. For these reasons, we refer to data from complete eBird checklists with effort information as semi-structured to distinguish from both most unstructured citizen science data and traditional structure scientific surveys. Exercise Take a few minutes to explore the EBD and compare it to the checklists online. Notice above that we had to reference the full path to the text files. In general, it’s best to avoid using absolute paths in R scripts because it makes them less portable–if you’re sharing the files with someone else, they’ll need to change the file paths to point to the location where they’ve stored the eBird data. The R package auk provides a workaround for this, by allowing users to set an environment variable (EDB_PATH) that points to the directory containing the eBird data. To set this variable, use the function auk_set_ebd_path(). For example, if the EBD and Sampling Event Data files are in ~/data/ebird/, use: auk_set_ebd_path(&quot;~/data/ebird/&quot;) The function auk_ebd() creates an R object referencing the EBD text file. Now that we’ve set up an EBD path, we can reference the EBD directly within auk_ebd() even though it’s not in our working directory. # the file isn&#39;t in out working directory file.exists(&quot;ebd_2015-2016_yucatan.txt&quot;) #&gt; [1] FALSE # yet auk can still find it auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) #&gt; Input #&gt; EBD: /Users/mes335/data/ebird/ebd_2015-2016_yucatan.txt #&gt; #&gt; Output #&gt; Filters not executed #&gt; #&gt; Filters #&gt; Species: all #&gt; Countries: all #&gt; States: all #&gt; BCRs: all #&gt; Bounding box: full extent #&gt; Date: all #&gt; Start time: all #&gt; Last edited date: all #&gt; Protocol: all #&gt; Project code: all #&gt; Duration: all #&gt; Distance travelled: all #&gt; Records with breeding codes only: no #&gt; Complete checklists only: no You should now see the EBD text file referenced as Input in this auk_ebd object. The remainder of the information printed will be the topic of the next section. Checkpoint Were you able to create an auk_ebd object referencing the EBD without specifying the full path? "],
["filter.html", "Lesson 4 Filtering 4.1 Defining filters 4.2 Execute filters", " Lesson 4 Filtering The EBD is huge, much too large to be read into R. So, if we want to work with these data, we first need to extract a small enough subset that it can be processed in R. This is the main purpose of the auk package: it uses the unix command line utility AWK to extract data from the EBD. There are three steps to this filtering process: Set up a reference to the EBD text file with auk_ebd(). Define a set of filters. Compile those filters into an AWK script and run it. Tip Filtering with auk can be fairly coarse, we just need to make the data small enough to read into R. Once the data are in R, they can be further refined 4.1 Defining filters The types of filters that can be applied to the EBD fall into four categories: Species Region Season Protocol and effort Each specific filter is implemented by a different function in auk. Visit the documentation on filters on the auk website for a complete list. Each of these functions defines a filter on a column within the EBD. For example, auk_country() will define a filter allowing us to extract data from a subset of countries from the EBD. To define a filter, start by creating an auk_ebd object, then pipe this into one of the filtering functions. library(auk) auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) %&gt;% auk_country(&quot;Guatemala&quot;) #&gt; Input #&gt; EBD: /Users/mes335/data/ebird/ebd_2015-2016_yucatan.txt #&gt; #&gt; Output #&gt; Filters not executed #&gt; #&gt; Filters #&gt; Species: all #&gt; Countries: GT #&gt; States: all #&gt; BCRs: all #&gt; Bounding box: full extent #&gt; Date: all #&gt; Start time: all #&gt; Last edited date: all #&gt; Protocol: all #&gt; Project code: all #&gt; Duration: all #&gt; Distance travelled: all #&gt; Records with breeding codes only: no #&gt; Complete checklists only: no Notice that when the auk_ebd object is printed, it tells us what filters have been defined. At this point, nothing has been done to the EBD, we’ve just defined the filter, we haven’t executed it yet. Tip Consult the Function Reference section of the auk website for a full list of available filters. In general, you should think about filtering on region, season, and species, so let’s build upon what we already have and add some more filters. For example, if we wanted all Resplendant Quetzal records from Guatemala in June 2015 we would use the following filters: auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(&quot;Resplendent Quetzal&quot;) %&gt;% auk_country(&quot;Guatemala&quot;) %&gt;% auk_date(c(&quot;2015-06-01&quot;, &quot;2015-06-30&quot;)) #&gt; Input #&gt; EBD: /Users/mes335/data/ebird/ebd_2015-2016_yucatan.txt #&gt; #&gt; Output #&gt; Filters not executed #&gt; #&gt; Filters #&gt; Species: Pharomachrus mocinno #&gt; Countries: GT #&gt; States: all #&gt; BCRs: all #&gt; Bounding box: full extent #&gt; Date: 2015-06-01 - 2015-06-30 #&gt; Start time: all #&gt; Last edited date: all #&gt; Protocol: all #&gt; Project code: all #&gt; Duration: all #&gt; Distance travelled: all #&gt; Records with breeding codes only: no #&gt; Complete checklists only: no Tip The filtering functions in auk check the arguments you provide and will throw an error if there’s something wrong. Filtering the EBD takes a long time, so it’s better to get an error now rather than realizing you made a mistake after waiting several hours for the extraction process to complete. auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) %&gt;% # typo in species name auk_species(&quot;Resplendant Quetzal&quot;) #&gt; Error in auk_species.auk_ebd(., &quot;Resplendant Quetzal&quot;): The following species were not found in the eBird taxonomy: #&gt; Resplendant Quetzal auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) %&gt;% # non-sequential dates auk_date(c(&quot;2016-06-01&quot;, &quot;2015-06-30&quot;)) #&gt; Error: date[1] not less than or equal to date[2] Exercise Define filters to extract Magnolia Warbler observations from Belize on checklists that started between 5 and 9 am and used either the Traveling or Stationary protocols. Consult the list of filters to see which ones you’ll need to use. Solution auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(&quot;Magnolia Warbler&quot;) %&gt;% auk_country(&quot;BZ&quot;) %&gt;% auk_protocol(c(&quot;Traveling&quot;, &quot;Stationary&quot;)) %&gt;% auk_time(c(&quot;5:00&quot;, &quot;9:00&quot;)) #&gt; Input #&gt; EBD: /Users/mes335/data/ebird/ebd_2015-2016_yucatan.txt #&gt; #&gt; Output #&gt; Filters not executed #&gt; #&gt; Filters #&gt; Species: Setophaga magnolia #&gt; Countries: BZ #&gt; States: all #&gt; BCRs: all #&gt; Bounding box: full extent #&gt; Date: all #&gt; Start time: 05:00-09:00 #&gt; Last edited date: all #&gt; Protocol: Traveling, Stationary #&gt; Project code: all #&gt; Duration: all #&gt; Distance travelled: all #&gt; Records with breeding codes only: no #&gt; Complete checklists only: no Tip In general, when using the effort filters like auk_time() or auk_distance(), it’s best to be a bit coarse. You can always refine the filters later once the data are in R, and starting with a coarse filter gives you some wiggle room if you later realize you want to make adjustments. Remember: the initial filtering with auk takes a long time, it’s best to limit the number of times you do this. When filtering by date, you may need to extract records from a given date range regardless of year. For this situation, the auk_date() function can accept wildcards for the year. For example, we can rewrite the above Resplendent Quetzal example to get observations from June of any year. auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(&quot;Resplendent Quetzal&quot;) %&gt;% auk_country(&quot;Guatemala&quot;) %&gt;% auk_date(c(&quot;*-06-01&quot;, &quot;*-06-30&quot;)) #&gt; Input #&gt; EBD: /Users/mes335/data/ebird/ebd_2015-2016_yucatan.txt #&gt; #&gt; Output #&gt; Filters not executed #&gt; #&gt; Filters #&gt; Species: Pharomachrus mocinno #&gt; Countries: GT #&gt; States: all #&gt; BCRs: all #&gt; Bounding box: full extent #&gt; Date: *-06-01 - *-06-30 #&gt; Start time: all #&gt; Last edited date: all #&gt; Protocol: all #&gt; Project code: all #&gt; Duration: all #&gt; Distance travelled: all #&gt; Records with breeding codes only: no #&gt; Complete checklists only: no 4.1.1 Complete checklists One of the most important filters is auk_complete(), which limits observations to those from complete checklists. As we’ve already seen, with complete checklists we can infer non-detections from the data. For most scientific applications, it’s critical that we have complete checklists, so we can generate presence-absence data. Exercise Define filters to extract Horned Guan and Highland Guan records from complete checklists in Chiapas, Mexico. Hint: you should use the auk_state() filter. Solution auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(c(&quot;Horned Guan&quot;, &quot;Highland Guan&quot;)) %&gt;% auk_state(&quot;MX-CHP&quot;) %&gt;% auk_complete() #&gt; Input #&gt; EBD: /Users/mes335/data/ebird/ebd_2015-2016_yucatan.txt #&gt; #&gt; Output #&gt; Filters not executed #&gt; #&gt; Filters #&gt; Species: Oreophasis derbianus, Penelopina nigra #&gt; Countries: all #&gt; States: MX-CHP #&gt; BCRs: all #&gt; Bounding box: full extent #&gt; Date: all #&gt; Start time: all #&gt; Last edited date: all #&gt; Protocol: all #&gt; Project code: all #&gt; Duration: all #&gt; Distance travelled: all #&gt; Records with breeding codes only: no #&gt; Complete checklists only: yes Tip To find the state code, consult the ebird_states data frame or visit the Explore page on the eBird website and enter the state name under Explore Region. The state code will appear after region/ in the URL. For example, for Chiapas the URL is https://ebird.org/region/MX-CHP?yr=all and the state code is therefore MX-CHP. Checkpoint Are there any questions about defining filters on the EBD? 4.2 Execute filters Once you have an auk_ebd object with a set of filters defined, you can execute those filters with auk_filter(). This function compiles the filters into an AWK script, then runs that script to produce a text file with the defined subset of the EBD. We’ll store this output file within the data/ subdirectory of the project directory. Note that filtering on the full EBD will take at least a couple hours, so be prepared to wait awhile. Let’s define filters to extract Yellow-rumped Warbler observations in Guatemala that appear on complete traveling or stationary checklists, then execute those filters. ebd_filtered &lt;- auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(&quot;Yellow-rumped Warbler&quot;) %&gt;% auk_country(&quot;GT&quot;) %&gt;% auk_protocol(c(&quot;Traveling&quot;, &quot;Stationary&quot;)) %&gt;% auk_complete() %&gt;% auk_filter(file = &quot;data/ebd_yerwar.txt&quot;) Take a look at this file and notice that we’ve drastically reduced the size. It can now be imported into R without any issues. Checkpoint Were you able to correctly extract the Yellow-rumped Warbler data? Any questions on filtering? "],
["import.html", "Lesson 5 Importing Data 5.1 Group checklists 5.2 Taxonomy", " Lesson 5 Importing Data In the previous lesson, we extracted a subset of the EBD containing Yellow-rumped Warbler observations from Guatemala. The output file created by auk_filter() is a tab-seperated text file and could be read into R using read.delim() or readr::read_tsv(); however, auk has a function specifically for reading the EBD. read_ebd() does the following: Reads the data using data.table::fread(), which is much faster than read.delim(). Sets the correct data types for the columns. Cleans up the column names so they are all snake_case. Automatically performs some post processing steps, which will be covered later in this lesson. Let’s read in the data! library(auk) library(dplyr) ebd &lt;- read_ebd(&quot;data/ebd_yerwar.txt&quot;, unique = FALSE, rollup = FALSE) glimpse(ebd) #&gt; Observations: 276 #&gt; Variables: 46 #&gt; $ global_unique_identifier [3m[90m&lt;chr&gt;[39m[23m &quot;URN:CornellLabOfOrnithology:EBIRD:… #&gt; $ last_edited_date [3m[90m&lt;chr&gt;[39m[23m &quot;2018-09-09 12:17:58&quot;, &quot;2018-09-09 … #&gt; $ taxonomic_order [3m[90m&lt;dbl&gt;[39m[23m 31814, 31814, 31814, 31816, 31814, … #&gt; $ category [3m[90m&lt;chr&gt;[39m[23m &quot;species&quot;, &quot;species&quot;, &quot;species&quot;, &quot;i… #&gt; $ common_name [3m[90m&lt;chr&gt;[39m[23m &quot;Yellow-rumped Warbler&quot;, &quot;Yellow-ru… #&gt; $ scientific_name [3m[90m&lt;chr&gt;[39m[23m &quot;Setophaga coronata&quot;, &quot;Setophaga co… #&gt; $ subspecies_common_name [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, &quot;Yellow-rumped Warbler … #&gt; $ subspecies_scientific_name [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, &quot;Setophaga coronata aud… #&gt; $ observation_count [3m[90m&lt;chr&gt;[39m[23m &quot;8&quot;, &quot;8&quot;, &quot;8&quot;, &quot;1&quot;, &quot;10&quot;, &quot;1&quot;, &quot;10&quot;… #&gt; $ breeding_bird_atlas_code [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ breeding_bird_atlas_category [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ age_sex [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ country [3m[90m&lt;chr&gt;[39m[23m &quot;Guatemala&quot;, &quot;Guatemala&quot;, &quot;Guatemal… #&gt; $ country_code [3m[90m&lt;chr&gt;[39m[23m &quot;GT&quot;, &quot;GT&quot;, &quot;GT&quot;, &quot;GT&quot;, &quot;GT&quot;, &quot;GT&quot;,… #&gt; $ state [3m[90m&lt;chr&gt;[39m[23m &quot;Baja Verapaz&quot;, &quot;Baja Verapaz&quot;, &quot;Ba… #&gt; $ state_code [3m[90m&lt;chr&gt;[39m[23m &quot;GT-BV&quot;, &quot;GT-BV&quot;, &quot;GT-BV&quot;, &quot;GT-AV&quot;,… #&gt; $ county [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ county_code [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ iba_code [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ bcr_code [3m[90m&lt;int&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ usfws_code [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ atlas_block [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ locality [3m[90m&lt;chr&gt;[39m[23m &quot;Finca Santo Tomas&quot;, &quot;Finca Santo T… #&gt; $ locality_id [3m[90m&lt;chr&gt;[39m[23m &quot;L3244964&quot;, &quot;L3244964&quot;, &quot;L3244964&quot;,… #&gt; $ locality_type [3m[90m&lt;chr&gt;[39m[23m &quot;P&quot;, &quot;P&quot;, &quot;P&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, … #&gt; $ latitude [3m[90m&lt;dbl&gt;[39m[23m 15.2, 15.2, 15.2, 15.2, 15.2, 15.2,… #&gt; $ longitude [3m[90m&lt;dbl&gt;[39m[23m -90.3, -90.3, -90.3, -90.3, -90.3, … #&gt; $ observation_date [3m[90m&lt;date&gt;[39m[23m 2015-12-26, 2015-12-26, 2015-12-26… #&gt; $ time_observations_started [3m[90m&lt;chr&gt;[39m[23m &quot;14:26:00&quot;, &quot;14:26:00&quot;, &quot;14:26:00&quot;,… #&gt; $ observer_id [3m[90m&lt;chr&gt;[39m[23m &quot;obsr414683&quot;, &quot;obsr418529&quot;, &quot;obsr41… #&gt; $ sampling_event_identifier [3m[90m&lt;chr&gt;[39m[23m &quot;S26466410&quot;, &quot;S26466240&quot;, &quot;S2646791… #&gt; $ protocol_type [3m[90m&lt;chr&gt;[39m[23m &quot;Stationary&quot;, &quot;Stationary&quot;, &quot;Statio… #&gt; $ protocol_code [3m[90m&lt;chr&gt;[39m[23m &quot;P21&quot;, &quot;P21&quot;, &quot;P21&quot;, &quot;P22&quot;, &quot;P21&quot;, … #&gt; $ project_code [3m[90m&lt;chr&gt;[39m[23m &quot;EBIRD&quot;, &quot;EBIRD&quot;, &quot;EBIRD&quot;, &quot;EBIRD&quot;,… #&gt; $ duration_minutes [3m[90m&lt;int&gt;[39m[23m 15, 15, 15, 68, 15, 68, 15, 15, 120… #&gt; $ effort_distance_km [3m[90m&lt;dbl&gt;[39m[23m NA, NA, NA, 7.00, NA, 7.00, NA, NA,… #&gt; $ effort_area_ha [3m[90m&lt;dbl&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ number_observers [3m[90m&lt;int&gt;[39m[23m 3, 3, 3, 3, 3, 3, 3, 3, 4, 1, 1, 5,… #&gt; $ all_species_reported [3m[90m&lt;lgl&gt;[39m[23m TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,… #&gt; $ group_identifier [3m[90m&lt;chr&gt;[39m[23m &quot;G1514667&quot;, &quot;G1514667&quot;, &quot;G1514667&quot;,… #&gt; $ has_media [3m[90m&lt;lgl&gt;[39m[23m FALSE, FALSE, FALSE, FALSE, FALSE, … #&gt; $ approved [3m[90m&lt;lgl&gt;[39m[23m TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,… #&gt; $ reviewed [3m[90m&lt;lgl&gt;[39m[23m FALSE, FALSE, FALSE, FALSE, FALSE, … #&gt; $ reason [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… #&gt; $ trip_comments [3m[90m&lt;chr&gt;[39m[23m &quot;&lt;br /&gt;Enviado desde eBird Android … #&gt; $ species_comments [3m[90m&lt;chr&gt;[39m[23m NA, NA, NA, NA, NA, NA, NA, NA, NA,… We’ll cover the use of unique = FALSE and rollup = FALSE next. For now, let’s just look at the data. Exercise Take a minute to explore these data using glimpse() and View(). Familiarize yourself with the columns. Be sure you can find the effort columns and the observation_count column. Checkpoint Do you have the data in a data frame? Does anyone have any questions about the data so far? 5.1 Group checklists eBird allows users to share checklists with other eBird users that they’re birding with. This results it multiple copies of some checklists in the database. Group checklists can be identified in the data because they have the group_identifier column populated. Let’s take a look at some these checklists. ebd %&gt;% filter(!is.na(group_identifier)) %&gt;% select(sampling_event_identifier, group_identifier) %&gt;% head() #&gt; # A tibble: 6 x 2 #&gt; sampling_event_identifier group_identifier #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 S26466410 G1514667 #&gt; 2 S26466240 G1514667 #&gt; 3 S26467913 G1514667 #&gt; 4 S26033869 G1480977 #&gt; 5 S26467907 G1514670 #&gt; 6 S26064931 G1480977 We see that there are multiple checklists with the same group_identifier, implying that these checklists have been shared and are duplicates. Let’s look at one of these on the eBird website: https://ebird.org/view/checklist/S26064931 As it turns out, group checklists aren’t exact duplicates; once a checklist has been shared the individual checklists can diverge in terms of the species seen, the counts for each species, and even the protocol and effort. In most cases, you’ll only want to retain one of these checklists, but it’s not trivial to do so because the checklists are only partial duplicates. The function auk_unique() manages this for you. Specifically, for each species, it retains only the first observation of that species, which is typically the one submitted by the primary observer (i.e. the person who recorded the original checklist). keep_one &lt;- auk_unique(ebd) nrow(ebd) #&gt; [1] 276 nrow(keep_one) #&gt; [1] 123 Note that a new field has been created (checklist_id), which is populated with group_identifier for group checklists and sampling_event_identifier otherwise; this is now a unique identifier for checklists. In addition, the full set of observer and sampling event identifiers has been retained in a comma seperated format. keep_one %&gt;% filter(!is.na(group_identifier)) %&gt;% select(checklist_id, sampling_event_identifier, group_identifier, observer_id) %&gt;% head() #&gt; # A tibble: 6 x 4 #&gt; checklist_id sampling_event_identif… group_identifier observer_id #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 G1125167 S21118307,S21556219 G1125167 obsr553524,obsr172… #&gt; 2 G1100467 S21235386,S21244259,S2… G1100467 obsr503360,obsr553… #&gt; 3 G1135829 S21569933,S21684780 G1135829 obsr276876,obsr277… #&gt; 4 G1769139 S21608832,S29779877 G1769139 obsr553208,obsr662… #&gt; 5 G1173637 S22200277,S22269150,S2… G1173637 obsr458611,obsr432… #&gt; 6 G1173395 S22263863,S22266171,S2… G1173395 obsr458611,obsr412… By default, whever you import data with read_ebd() it calls auk_unique() automatically; however, this behaviour can be controlled with the unique argument. So, for example, the following will import data and remove duplicates. ebd &lt;- read_ebd(&quot;data/ebd_yerwar.txt&quot;, rollup = FALSE) Tip auk_unique() takes a long time to run on large datasets. Consider using read_ebd(unique = FALSE) when importing large text files to speed up the process. 5.2 Taxonomy eBird users can enter data for a wide range of taxa in addition to species. Observations can be reported at a level more granular than species (e.g. subspecies or recognizable forms) or at a higher level than species (e.g. spuhs, slashes, and hybrids). All the different taxa that can be reported are contained in the eBird taxonomy, which is updated every year in August. The eBird Science page has a subsection with details on the eBird taxonomy, and the taxonomy itself is available in the package as a dataframe in the auk package. glimpse(ebird_taxonomy) #&gt; Observations: 16,248 #&gt; Variables: 8 #&gt; $ scientific_name &lt;chr&gt; &quot;Struthio camelus&quot;, &quot;Struthio molybdophanes&quot;, &quot;S… #&gt; $ common_name &lt;chr&gt; &quot;Common Ostrich&quot;, &quot;Somali Ostrich&quot;, &quot;Common/Soma… #&gt; $ species_code &lt;chr&gt; &quot;ostric2&quot;, &quot;ostric3&quot;, &quot;y00934&quot;, &quot;grerhe1&quot;, &quot;lesr… #&gt; $ category &lt;chr&gt; &quot;species&quot;, &quot;species&quot;, &quot;slash&quot;, &quot;species&quot;, &quot;speci… #&gt; $ taxon_order &lt;dbl&gt; 1, 6, 7, 8, 14, 15, 18, 19, 20, 21, 26, 27, 30, … #&gt; $ order &lt;chr&gt; &quot;Struthioniformes&quot;, &quot;Struthioniformes&quot;, &quot;Struthi… #&gt; $ family &lt;chr&gt; &quot;Struthionidae&quot;, &quot;Struthionidae&quot;, &quot;Struthionidae… #&gt; $ report_as &lt;chr&gt; NA, NA, NA, NA, NA, &quot;lesrhe2&quot;, &quot;lesrhe2&quot;, NA, NA… # you can even report that you saw a generic bird! filter(ebird_taxonomy, common_name == &quot;bird sp.&quot;) #&gt; scientific_name common_name species_code category taxon_order order #&gt; 1 Aves sp. bird sp. bird1 spuh 34339 &lt;NA&gt; #&gt; family report_as #&gt; 1 &lt;NA&gt; &lt;NA&gt; For taxa below the species level, the report_as field specifies the species that this taxa falls under. For example, the Myrtle warbler rolls up to Yellow-rumped Warbler. # myrtle warbler filter(ebird_taxonomy, common_name == &quot;Yellow-rumped Warbler (Myrtle)&quot;) %&gt;% select(common_name, category, report_as) #&gt; common_name category report_as #&gt; 1 Yellow-rumped Warbler (Myrtle) issf yerwar # rolls up to yellow-rumped warbler filter(ebird_taxonomy, species_code == &quot;yerwar&quot;) %&gt;% select(common_name, category, report_as) #&gt; common_name category report_as #&gt; 1 Yellow-rumped Warbler species &lt;NA&gt; The EBD contains a subspecies column, which is populated when an observer has identified a bird below species level. In the EBD extract we’re working with, we have three different subspecies of Yellow-rumped Warbler: count(ebd, common_name, subspecies_common_name) #&gt; # A tibble: 4 x 3 #&gt; common_name subspecies_common_name n #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Yellow-rumped Warbler &lt;NA&gt; 59 #&gt; 2 Yellow-rumped Warbler Yellow-rumped Warbler (Audubon&#39;s) 38 #&gt; 3 Yellow-rumped Warbler Yellow-rumped Warbler (Goldman&#39;s) 14 #&gt; 4 Yellow-rumped Warbler Yellow-rumped Warbler (Myrtle) 12 It’s even possible to have multiple subspecies of the same species on a single checklist. filter(ebd, checklist_id == &quot;S22725024&quot;) %&gt;% select(checklist_id, common_name, subspecies_common_name, observation_count) #&gt; # A tibble: 2 x 4 #&gt; checklist_id common_name subspecies_common_name observation_cou… #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 S22725024 Yellow-rumped Wa… Yellow-rumped Warbler (M… 1 #&gt; 2 S22725024 Yellow-rumped Wa… Yellow-rumped Warbler (A… 1 For most uses, you’ll want eBird data at the species level, which means dropping higher level taxa and rolling lower level taxa up to species level, making sure to sum the counts if multiple subspecies were present. The function auk_rollup() handles these taxonomic matters for you. no_subsp &lt;- auk_rollup(ebd) filter(no_subsp, checklist_id == &quot;S22725024&quot;) %&gt;% select(checklist_id, common_name, observation_count) #&gt; # A tibble: 1 x 3 #&gt; checklist_id common_name observation_count #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 S22725024 Yellow-rumped Warbler 2 By default, when you import data with read_ebd() it calls auk_rollup() automatically; however, this behaviour can be controlled with the rollup argument. So, for example, the following will import data and remove duplicates and report all records at species level. ebd &lt;- read_ebd(&quot;data/ebd_yerwar.txt&quot;) Checkpoint Any questions on data import, taxonomy, or group checklists? "],
["presabs.html", "Lesson 6 Presence-absence Data 6.1 Filtering 6.2 Zero-filling 6.3 Tidying up", " Lesson 6 Presence-absence Data Up to this point we’ve been working with presence-only data. The EBD, and eBird checklists in general, only explicitly record positive observations of species. However, if we limit ourselves to complete checklists, we can fill in the implied zero counts for any checklists on which a given species isn’t explicitly reported to generate presence-absence data. We refer to this process as zero-filling the eBird data. Zero-filling relies on the Sampling Event Data, which is a tab-seperated text file containing checklist-level information. This file contains the full population of checklists in the eBird database. If we apply exactly the same set of filters to both the EBD and the Sampling Event Data we can assume that any checklist with no observations for a given species in the EBD should get a zero-count record added to the dataset. So, producing presence-absence eBird data is a two-step process: Simultaneously filter the EBD and Sampling Event Data, making sure to only use complete checklists. Read both files into R and zero-fill the EBD using the full population of checklists from the Sampling Event Data. Tip When we say “presence-absence” what we really mean by absence is that the species was not detected, it’s entirely possible that the species was present but the observer didn’t detect it. Checkpoint Are there any conceptual questions about the process of zero-filling? 6.1 Filtering Simultaneously filtering the EBD and Sampling Event Data is done in almost the exact same way as filtering the EBD alone. The only difference is that we provide both files to auk_ebd() and two corresponding output files to auk_filter(). For example, we can extract all American Flamingo observations from January in the Mexican state of Yucatán in preparation for zero-filling. Let’s do this in a new script 02_zerofill.R. library(auk) library(dplyr) f_ebd &lt;- &quot;data/ebd_amefla.txt&quot; f_sed &lt;- &quot;data/sed_amefla.txt&quot; ebd_filt &lt;- auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;, file_sampling = &quot;ebd_sampling_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(&quot;American Flamingo&quot;) %&gt;% auk_state(&quot;MX-YUC&quot;) %&gt;% auk_date(c(&quot;*-01-01&quot;, &quot;*-01-31&quot;)) %&gt;% auk_complete() %&gt;% auk_filter(f_ebd, file_sampling = f_sed) We now have two output files that have been extracted using the same set of filters, apart from the species filter, which only applies to the EBD. We can read these files into R individually: ebd_only &lt;- read_ebd(f_ebd) sed_only &lt;- read_sampling(f_sed) nrow(ebd_only) #&gt; [1] 51 nrow(sed_only) #&gt; [1] 336 So, we have 336 checklists in the Sampling Event Data and, of those, 51 have Flamingo observations on them. Checkpoint Were you able to filter and import the EBD and Sampling Event Data? Did you get the correct number of rows in both files? Exercise You’re studying Hooded Warblers wintering (November-February) in Belize. Extract eBird data in preparation for zero-filling, then read in the results and explore them. Hint: consult the Details section of the documentation for auk_date() to see how to filter a range of dates that wrap around the year end. Solution f_ebd_hw &lt;- &quot;data/ebd_hoowar.txt&quot; f_sed_hw &lt;- &quot;data/sed_hoowar.txt&quot; # filter ebd_filt &lt;- auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;, file_sampling = &quot;ebd_sampling_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(&quot;Hooded Warbler&quot;) %&gt;% auk_country(&quot;BZ&quot;) %&gt;% # when using wildcards, dates can wrap around the year end auk_date(c(&quot;*-11-01&quot;, &quot;*-02-29&quot;)) %&gt;% auk_complete() %&gt;% auk_filter(f_ebd_hw, file_sampling = f_sed_hw) # import the data ebd_only_hw &lt;- read_ebd(f_ebd_hw) sed_only_hw &lt;- read_sampling(f_sed_hw) 6.2 Zero-filling Now that we have these two datasets–containing checklist and species information, respectively–we can use the function auk_zerofill() to combine them to produce presence-absence data. This function also imports the data, and handles group checklists and taxonomic rollup automatically, we just have to pass it the paths to the two files. Let’s do this with the American Flamingo data. ebd_zf &lt;- auk_zerofill(f_ebd, sampling_events = f_sed) ebd_zf #&gt; Zero-filled EBD: 336 unique checklists, for 1 species. By default, auk_zerofill() returns the data as a list of two dataframes: sampling_events contains all the checklist and observations contains just the counts and presence-absence data for each species on each checklist. This compact format reduces the size of the data because checklist information isn’t replicated for every species observation. glimpse(ebd_zf$observations) #&gt; Observations: 336 #&gt; Variables: 4 #&gt; $ checklist_id &lt;chr&gt; &quot;G1089999&quot;, &quot;G1092350&quot;, &quot;G1095290&quot;, &quot;G1095467&quot;… #&gt; $ scientific_name &lt;chr&gt; &quot;Phoenicopterus ruber&quot;, &quot;Phoenicopterus ruber&quot;… #&gt; $ observation_count &lt;chr&gt; &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;3&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;… #&gt; $ species_observed &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE… glimpse(ebd_zf$sampling_events) #&gt; Observations: 336 #&gt; Variables: 31 #&gt; $ checklist_id &lt;chr&gt; &quot;S27296139&quot;, &quot;S27164098&quot;, &quot;S27171657&quot;,… #&gt; $ last_edited_date &lt;chr&gt; &quot;2018-08-06 17:50:11&quot;, &quot;2016-01-27 19:… #&gt; $ country &lt;chr&gt; &quot;Mexico&quot;, &quot;Mexico&quot;, &quot;Mexico&quot;, &quot;Mexico&quot;… #&gt; $ country_code &lt;chr&gt; &quot;MX&quot;, &quot;MX&quot;, &quot;MX&quot;, &quot;MX&quot;, &quot;MX&quot;, &quot;MX&quot;, &quot;M… #&gt; $ state &lt;chr&gt; &quot;Yucatán&quot;, &quot;Yucatán&quot;, &quot;Yucatán&quot;, &quot;Yuca… #&gt; $ state_code &lt;chr&gt; &quot;MX-YUC&quot;, &quot;MX-YUC&quot;, &quot;MX-YUC&quot;, &quot;MX-YUC&quot;… #&gt; $ county &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ county_code &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ iba_code &lt;chr&gt; &quot;MX_186&quot;, &quot;MX_186&quot;, NA, NA, &quot;MX_186&quot;, … #&gt; $ bcr_code &lt;int&gt; 55, NA, 56, 56, NA, 56, 55, 55, 55, 56… #&gt; $ usfws_code &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ atlas_block &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ locality &lt;chr&gt; &quot;CSF1&quot;, &quot;Rio Lagartos (pueblo)&quot;, &quot;Rese… #&gt; $ locality_id &lt;chr&gt; &quot;L3629436&quot;, &quot;L1850457&quot;, &quot;L3620341&quot;, &quot;L… #&gt; $ locality_type &lt;chr&gt; &quot;P&quot;, &quot;H&quot;, &quot;H&quot;, &quot;P&quot;, &quot;P&quot;, &quot;H&quot;, &quot;P&quot;, &quot;H&quot;… #&gt; $ latitude &lt;dbl&gt; 21.6, 21.6, 20.6, 21.4, 21.6, 20.7, 21… #&gt; $ longitude &lt;dbl&gt; -88.2, -88.2, -88.2, -88.2, -88.2, -88… #&gt; $ observation_date &lt;date&gt; 2016-01-30, 2016-01-27, 2016-01-27, 2… #&gt; $ time_observations_started &lt;chr&gt; &quot;07:00:00&quot;, &quot;15:50:00&quot;, &quot;07:25:00&quot;, &quot;0… #&gt; $ observer_id &lt;chr&gt; &quot;obs539688&quot;, &quot;obs439237&quot;, &quot;obs106177&quot;,… #&gt; $ sampling_event_identifier &lt;chr&gt; &quot;S27296139&quot;, &quot;S27164098&quot;, &quot;S27171657&quot;,… #&gt; $ protocol_type &lt;chr&gt; &quot;Stationary&quot;, &quot;Traveling&quot;, &quot;Traveling&quot;… #&gt; $ protocol_code &lt;chr&gt; &quot;P21&quot;, &quot;P22&quot;, &quot;P22&quot;, &quot;P21&quot;, &quot;P21&quot;, &quot;P2… #&gt; $ project_code &lt;chr&gt; &quot;EBIRD_MEX&quot;, &quot;EBIRD_MEX&quot;, &quot;EBIRD&quot;, &quot;EB… #&gt; $ duration_minutes &lt;int&gt; 10, 303, 180, 10, 10, 240, 10, 150, 60… #&gt; $ effort_distance_km &lt;dbl&gt; NA, 2.000, 11.104, NA, NA, 1.000, NA, … #&gt; $ effort_area_ha &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ number_observers &lt;int&gt; 1, 2, 7, 2, 1, 1, 1, 1, 2, 4, 1, 1, 3,… #&gt; $ all_species_reported &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TR… #&gt; $ group_identifier &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ trip_comments &lt;chr&gt; NA, NA, &quot;2.1 miles walked, 4.8 driven … However, in this case object size isn’t an issue, and it’s easier to work with a single dataframe, so we can collapse the data with collapse_zerofill(). ebd_zf_df &lt;- collapse_zerofill(ebd_zf) glimpse(ebd_zf_df) #&gt; Observations: 336 #&gt; Variables: 34 #&gt; $ checklist_id &lt;chr&gt; &quot;S27296139&quot;, &quot;S27164098&quot;, &quot;S27171657&quot;,… #&gt; $ last_edited_date &lt;chr&gt; &quot;2018-08-06 17:50:11&quot;, &quot;2016-01-27 19:… #&gt; $ country &lt;chr&gt; &quot;Mexico&quot;, &quot;Mexico&quot;, &quot;Mexico&quot;, &quot;Mexico&quot;… #&gt; $ country_code &lt;chr&gt; &quot;MX&quot;, &quot;MX&quot;, &quot;MX&quot;, &quot;MX&quot;, &quot;MX&quot;, &quot;MX&quot;, &quot;M… #&gt; $ state &lt;chr&gt; &quot;Yucatán&quot;, &quot;Yucatán&quot;, &quot;Yucatán&quot;, &quot;Yuca… #&gt; $ state_code &lt;chr&gt; &quot;MX-YUC&quot;, &quot;MX-YUC&quot;, &quot;MX-YUC&quot;, &quot;MX-YUC&quot;… #&gt; $ county &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ county_code &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ iba_code &lt;chr&gt; &quot;MX_186&quot;, &quot;MX_186&quot;, NA, NA, &quot;MX_186&quot;, … #&gt; $ bcr_code &lt;int&gt; 55, NA, 56, 56, NA, 56, 55, 55, 55, 56… #&gt; $ usfws_code &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ atlas_block &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ locality &lt;chr&gt; &quot;CSF1&quot;, &quot;Rio Lagartos (pueblo)&quot;, &quot;Rese… #&gt; $ locality_id &lt;chr&gt; &quot;L3629436&quot;, &quot;L1850457&quot;, &quot;L3620341&quot;, &quot;L… #&gt; $ locality_type &lt;chr&gt; &quot;P&quot;, &quot;H&quot;, &quot;H&quot;, &quot;P&quot;, &quot;P&quot;, &quot;H&quot;, &quot;P&quot;, &quot;H&quot;… #&gt; $ latitude &lt;dbl&gt; 21.6, 21.6, 20.6, 21.4, 21.6, 20.7, 21… #&gt; $ longitude &lt;dbl&gt; -88.2, -88.2, -88.2, -88.2, -88.2, -88… #&gt; $ observation_date &lt;date&gt; 2016-01-30, 2016-01-27, 2016-01-27, 2… #&gt; $ time_observations_started &lt;chr&gt; &quot;07:00:00&quot;, &quot;15:50:00&quot;, &quot;07:25:00&quot;, &quot;0… #&gt; $ observer_id &lt;chr&gt; &quot;obs539688&quot;, &quot;obs439237&quot;, &quot;obs106177&quot;,… #&gt; $ sampling_event_identifier &lt;chr&gt; &quot;S27296139&quot;, &quot;S27164098&quot;, &quot;S27171657&quot;,… #&gt; $ protocol_type &lt;chr&gt; &quot;Stationary&quot;, &quot;Traveling&quot;, &quot;Traveling&quot;… #&gt; $ protocol_code &lt;chr&gt; &quot;P21&quot;, &quot;P22&quot;, &quot;P22&quot;, &quot;P21&quot;, &quot;P21&quot;, &quot;P2… #&gt; $ project_code &lt;chr&gt; &quot;EBIRD_MEX&quot;, &quot;EBIRD_MEX&quot;, &quot;EBIRD&quot;, &quot;EB… #&gt; $ duration_minutes &lt;int&gt; 10, 303, 180, 10, 10, 240, 10, 150, 60… #&gt; $ effort_distance_km &lt;dbl&gt; NA, 2.000, 11.104, NA, NA, 1.000, NA, … #&gt; $ effort_area_ha &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ number_observers &lt;int&gt; 1, 2, 7, 2, 1, 1, 1, 1, 2, 4, 1, 1, 3,… #&gt; $ all_species_reported &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TR… #&gt; $ group_identifier &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… #&gt; $ trip_comments &lt;chr&gt; NA, NA, &quot;2.1 miles walked, 4.8 driven … #&gt; $ scientific_name &lt;chr&gt; &quot;Phoenicopterus ruber&quot;, &quot;Phoenicopteru… #&gt; $ observation_count &lt;chr&gt; &quot;0&quot;, &quot;5&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;… #&gt; $ species_observed &lt;lgl&gt; FALSE, TRUE, FALSE, FALSE, FALSE, FALS… Notice that in addition to the observation_count column, we now have a binary species_observered column specifying whether or not the species was observered on this checklist. You can also automatically collapse the data by using the collapse = TRUE argument to auk_zerofill(). Exercise Zero-fill and collapse the Hooded Warbler data you extracted in the previous exercise. Solution ebd_zf_hw &lt;- auk_zerofill(f_ebd_hw, f_sed_hw) Tip Whenever you’re zero-filling data it’s critical that you think about region and season (i.e. where and when) in addition to just the species. If you don’t do that, you’ll zero-fill the entire global EBD and your computer will explode. For example, consider a highly localized species like the Cozumel Vireo, endemic to the small island of Cozumel off the coast of Mexico. Let’s try just filtering on species. ebd_cozvir &lt;- auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;, file_sampling = &quot;ebd_sampling_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(&quot;Cozumel Vireo&quot;) %&gt;% auk_complete() %&gt;% auk_filter(&quot;data/ebd_cozvir.txt&quot;, &quot;data/sed_cozvir.txt&quot;) %&gt;% auk_zerofill(collapse = TRUE) table(ebd_cozvir$species_observed) #&gt; #&gt; FALSE TRUE #&gt; 35487 127 What we have here is the entire EBD (35 thousand checklists in the example dataset, and 36 million in the full EBD!) for a species that only occurs on one small island. Do we really care that a checklist in Anchorage doesn’t have Cozumel Vireo? In this situation, you would be better to identify the boundaries of the island and use auk_bbox() to spatially subset the data. ebd_cozvir &lt;- auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;, file_sampling = &quot;ebd_sampling_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(&quot;Cozumel Vireo&quot;) %&gt;% # lng_min, lat_min, lng_max, lat_max auk_bbox(c(-87.1, 20.2, -86.7, 20.6)) %&gt;% auk_complete() %&gt;% auk_filter(&quot;data/ebd_cozvir.txt&quot;, &quot;data/sed_cozvir.txt&quot;, overwrite = TRUE) %&gt;% auk_zerofill(collapse = TRUE) table(ebd_cozvir$species_observed) #&gt; #&gt; FALSE TRUE #&gt; 667 127 We have the same number of positive observations, but have now drastically reduced the number of checklists without Cozumel Vireo observations. 6.3 Tidying up We now have a zero-filled presence-absence dataset with duplicate group checklists removed and all observations at the species level. There are couple remaining steps that we typically run to clean up the data. First, you may have noticed some cases where observation_count is &quot;X&quot; in the data. This is what eBirders enter for the count to indicate that they didn’t count the number of individuals for a given species. arrange(ebd_zf_df, desc(observation_count)) %&gt;% select(checklist_id, observation_count) %&gt;% head(10) #&gt; # A tibble: 10 x 2 #&gt; checklist_id observation_count #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 S27259643 X #&gt; 2 G1546995 X #&gt; 3 G1533133 85 #&gt; 4 G1120861 8 #&gt; 5 G1140974 8 #&gt; 6 G1141753 690 #&gt; # … with 4 more rows It’s more appropriate to have the count as NA rather than &quot;X&quot; in this scenario. This will also allow us to convert the count column to integer rather than character. At this point, we’ll also assign an explicit distance of 0 to stationary checklists. zf_count &lt;- ebd_zf_df %&gt;% mutate(observation_count = if_else(observation_count == &quot;X&quot;, NA_character_, observation_count), observation_count = as.integer(observation_count), effort_distance_km = if_else(protocol_type == &quot;Stationary&quot;, 0, effort_distance_km)) Finally, depending on your application, you’ll likely want to do some further filtering of the data. For many uses, it’s a good idea to reduce the variation in detectability between checklists by imposing some constraints on the effort variables. You can think of this as partially standardizing the observation process in a post hoc fashion. For example, in part II of this workshop, we’ll restrict observations to those from checklists less than 5 hours long and 5 km in length, and with 10 or fewer observers. zf_effort &lt;- zf_count %&gt;% filter(duration_minutes &lt;= 60 * 5, effort_distance_km &lt;= 5, number_observers &lt;= 10) table(zf_count$species_observed) #&gt; #&gt; FALSE TRUE #&gt; 285 51 table(zf_effort$species_observed) #&gt; #&gt; FALSE TRUE #&gt; 264 24 We’ve reduced the amount of data, but also decreased the variability in effort, which will lead to better model performance if we use these data to model species distributions. "],
["applications.html", "Lesson 7 Applications 7.1 Frequency trajectories 7.2 Maps", " Lesson 7 Applications Now that we know how to extract and zero-fill data from eBird, let’s do something with these data! We’ll start by summarizing the data to show the trajectory of observation frequency over the course of the year. Next, we’ll make a basic presence-absence map of eBird observations. More advanced topics are covered in part II of this workshop, which focuses on using eBird data to model species distributions. We’ll start a new script for this lesson: 03_applications.R. 7.1 Frequency trajectories The genus Cardellina contains five New World warbler species, including some of the most spectacular birds in North America: Canada Warbler, Red Warbler, and Pink-headed Warbler. Let’s extract and zero-fill data for three of the species in this genus within Guatemala. library(auk) library(sf) library(rnaturalearth) library(lubridate) library(tidyverse) f_ebd &lt;- &quot;data/ebd_cardellina.txt&quot; f_sed &lt;- &quot;data/sed_cardellina.txt&quot; # extract filters &lt;- auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;, file_sampling = &quot;ebd_sampling_2015-2016_yucatan.txt&quot;) %&gt;% auk_species(c(&quot;Canada Warbler&quot;, &quot;Wilson&#39;s Warbler&quot;, &quot;Pink-headed Warbler&quot;)) %&gt;% auk_country(&quot;Guatemala&quot;) %&gt;% auk_complete() %&gt;% auk_filter(f_ebd, f_sed) # zero-fill cardellina_zf &lt;- auk_zerofill(f_ebd, f_sed, collapse = TRUE) count(cardellina_zf, scientific_name, species_observed) #&gt; # A tibble: 6 x 3 #&gt; scientific_name species_observed n #&gt; &lt;chr&gt; &lt;lgl&gt; &lt;int&gt; #&gt; 1 Cardellina canadensis FALSE 9058 #&gt; 2 Cardellina canadensis TRUE 93 #&gt; 3 Cardellina pusilla FALSE 6676 #&gt; 4 Cardellina pusilla TRUE 2475 #&gt; 5 Cardellina versicolor FALSE 8855 #&gt; 6 Cardellina versicolor TRUE 296 Next, let’s summarize these data, calculating the frequency of observation on eBird checklists by month. cardellina_freq &lt;- cardellina_zf %&gt;% mutate(month = month(observation_date)) %&gt;% group_by(scientific_name, month) %&gt;% summarize(obs_freq = mean(species_observed)) %&gt;% ungroup() In prepartion for plotting, we can add the common names of the species by joining in the ebird_taxonomy data frame, which is included with auk. In addition, we’ll convert the integer month numbers to dates–using the midpoint of each month–to aid axis labelling. cardellina_comm &lt;- cardellina_freq %&gt;% inner_join(ebird_taxonomy, by = &quot;scientific_name&quot;) %&gt;% select(common_name, month, obs_freq) %&gt;% mutate(month_midpoint = ymd(str_glue(&quot;2019-{month}-15&quot;))) Finally, let’s make a frequency trajectory for these four species. ggplot(cardellina_comm) + aes(x = month_midpoint, y = obs_freq, color = common_name) + geom_point() + geom_line() + scale_x_date(date_breaks = &quot;2 months&quot;, date_labels = &quot;%b&quot;) + scale_color_brewer(palette = &quot;Set1&quot;) + labs(x = &quot;Month&quot;, y = &quot;Observation Frequency&quot;, color = NULL) + theme(legend.position = &quot;bottom&quot;) We have several different patterns going on here: Pink-headed Warblers is a resident species, present year-round at fairly low abundance Wilson’s Warbler spends the winter in Guatemala and is common during that period Canada Warbler appears to only pass through Guatemala during migration 7.2 Maps Continuing with the same dataset, let’s make a presence-absence map for Pink-headed Warbler. We’ll start by filtering the zero-filled data to only Pink-headed Warbler observations and converting these points to a spatial format using the sf package. pihwar &lt;- cardellina_zf %&gt;% filter(scientific_name == &quot;Cardellina versicolor&quot;) %&gt;% st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) Next, we’ll use rnaturalearth to get some contextual GIS data to use in our maps. This is an amazing source for free GIS data for making maps. ne_country &lt;- ne_countries(continent = &quot;North America&quot;, returnclass = &quot;sf&quot;) %&gt;% st_geometry() ne_gt &lt;- ne_countries(country = &quot;Guatemala&quot;, returnclass = &quot;sf&quot;) %&gt;% st_geometry() # restrict to points falling within Guatemala, removes those over water pihwar &lt;- pihwar[ne_gt, ] Finally, we’ll make a presence-absence map, building it up in layers. There are lots excellent tools for mapping in R; however, here we’ll use the basic plot() function from the sf package. Other good options include ggplot2 and tmap. par(mar = c(0.25, 0.25, 0.25, 0.25)) # start by defining the bounds of the map with an empty plot plot(ne_gt, col = NA, border = NA) # borders plot(ne_country, col = &quot;grey80&quot;, border = &quot;white&quot;, add = TRUE) plot(ne_gt, col = &quot;grey70&quot;, border = &quot;white&quot;, add = TRUE) # not observed pihwar_abs &lt;- filter(pihwar, !species_observed) %&gt;% st_geometry() plot(pihwar_abs, col = alpha(&quot;grey20&quot;, 0.3), pch = 19, cex = 0.25, add = TRUE) # present pihwar_pres &lt;- filter(pihwar, species_observed) %&gt;% st_geometry() plot(pihwar_pres, col = alpha(&quot;orange&quot;, 1), pch = 19, cex = 0.5, add = TRUE) title(&quot;Pink-headed Warbler eBird Observations&quot;, line = -1) legend(&quot;bottomright&quot;, col = c(&quot;grey20&quot;, &quot;orange&quot;), legend = c(&quot;Not reported&quot;, &quot;Present&quot;), pch = 19) box() Based on this map, we see that Pink-headed Warbler is restricted to the southwestern highlands of Guatemala. Exercise Make a similar map of Wilson’s Warbler (Cardellina pusilla) observations. Solution # prepare data wilwar &lt;- cardellina_zf %&gt;% filter(scientific_name == &quot;Cardellina pusilla&quot;) %&gt;% mutate(pres_abs = if_else(species_observed, &quot;Present&quot;, &quot;Not detected&quot;)) %&gt;% st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) wilwar &lt;- wilwar[ne_gt, ] # make map par(mar = c(0.25, 0.25, 0.25, 0.25)) plot(ne_gt, col = NA, border = NA) plot(ne_country, col = &quot;grey80&quot;, border = &quot;white&quot;, add = TRUE) plot(ne_gt, col = &quot;grey70&quot;, border = &quot;white&quot;, add = TRUE) # not observed wilwar_abs &lt;- filter(wilwar, !species_observed) %&gt;% st_geometry() plot(wilwar_abs, col = alpha(&quot;grey20&quot;, 0.3), pch = 19, cex = 0.25, add = TRUE) # present wilwar_pres &lt;- filter(wilwar, species_observed) %&gt;% st_geometry() plot(wilwar_pres, col = alpha(&quot;orange&quot;, 1), pch = 19, cex = 0.5, add = TRUE) title(&quot;Wilson&#39;s Warbler eBird Observations&quot;, line = -1) legend(&quot;bottomright&quot;, col = c(&quot;grey20&quot;, &quot;orange&quot;), legend = c(&quot;Not reported&quot;, &quot;Present&quot;), pch = 19) box() "],
["advanced.html", "Lesson 8 Advanced Topics 8.1 Custom downloads 8.2 Preparing for occupancy modeling 8.3 Reducing file size 8.4 Land cover covariates", " Lesson 8 Advanced Topics 8.1 Custom downloads The full EBD is massive (over 200 GB) and takes a long time to process with auk (typically several hours). In some cases, there’ss a way around these issues. On the EBD download page, there’s a Custom Download form that allows you to request a subset of the EBD for a given species, within a region, and for a range of dates. After submitting a request, it will be processed on the eBird servers and a email will be sent to you with instructions for downloading the EBD extract. Recall from the lesson on zero-filling, that we extracted American Flamingo records from Mexico’s Yucatán state in January, and produced presence-absence data from this extract. Let’s try to do this with the Custom Download form. After the request is submitted an email will arrive with instrustions for downloading the following file. Download and unarchive this file, placing the text file in the data/ subdirectory of your project. It will quickly become clear that there are two challenges with this approach. First, the set of filters available in the Custom Download form is limited. For example, there’s no option to only extract observations from complete checklists or any way to get observations from a given month from any year. To address this, we can apply the additional filters after we’ve imported the data in R. Specifically, we’ll only keep observations from complete checklists in June. library(auk) library(lubridate) library(tidyverse) ebd &lt;- read_ebd(&quot;data/ebd_MX-YUC_grefla2_201501_201612_relApr-2019.txt&quot;) %&gt;% filter(month(observation_date) == 1, all_species_reported) The second challenge is that the Custom Download form only provides the positive observations from the EBD, it doesn’t provide the corresponding Sampling Event Data for zero-filling. However, the Sampling Event Data is much smaller than the EBD and quicker to process with auk. So, we can easily filter this file using the same set of filters we’ve already applied to the EBD. Note that auk_sampling() is used in place of auk_ebd() when we’re only filtering the sampling data and not the EBD. f_sed &lt;- &quot;data/sed-only_amefla.txt&quot; sed_filt &lt;- auk_sampling(&quot;ebd_sampling_2015-2016_yucatan.txt&quot;) %&gt;% auk_state(&quot;MX-YUC&quot;) %&gt;% auk_date(c(&quot;*-01-01&quot;, &quot;*-01-31&quot;)) %&gt;% auk_complete() %&gt;% auk_filter(&quot;data/sed-only_amefla.txt&quot;) sed &lt;- read_sampling(f_sed) Finally, we can combine these two dataframes together with auk_zerofill() to produce zero-filled presence-absence data. ebd_zf &lt;- auk_zerofill(ebd, sed, collapse = TRUE) We’ve produced exactly the same data as in Lesson 6; however, we’ve done so avoiding having to deal with the full EBD! 8.2 Preparing for occupancy modeling One common use of eBird data is for occupancy modeling with the R package unmarked. This workshop won’t cover occupancy modeling; however, unmarked requires data to be formatted in a very particular way and auk contains functions to do this, which we’ll cover in this lesson. We’ll continue with the American Flamingo data from the previous section. First, we need to extract the subset of observations that are suitable for occupancy modeling. In particular, occupancy models typically require data from repeated visits to a single site during a time frame over which the population can be considered closed. For example, let’s define the period of closure as the entire month of January in each year and a repeat visit as the same observer revisting a site with same latitude and longitude at least twice. The auk function filter_repeat_visits() is designed to extract a subset of eBird data of this form. visits &lt;- filter_repeat_visits(ebd_zf, min_obs = 2, max_obs = 10, annual_closure = TRUE, date_var = &quot;observation_date&quot;, site_vars = c(&quot;latitude&quot;, &quot;longitude&quot;, &quot;observer_id&quot;)) # entire data set nrow(visits) #&gt; [1] 112 # reduced data set nrow(ebd_zf) #&gt; [1] 336 # how many individual sites there are n_distinct(visits$site) #&gt; [1] 39 Three new columns are added to the dataset when using the function filter_repeat_visits(): site is a unique site ID, closure_id identifies the primary period of closure (in this example the year), and n_observations is the number of visits to each site. visits %&gt;% select(site, closure_id, n_observations) %&gt;% head() #&gt; # A tibble: 6 x 3 #&gt; site closure_id n_observations #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 20.359625_-89.7705531_obs282508_2015 2015 3 #&gt; 2 20.359625_-89.7705531_obs282508_2015 2015 3 #&gt; 3 20.359625_-89.7705531_obs282508_2015 2015 3 #&gt; 4 20.539589_-89.341231_obs536411_2015 2015 2 #&gt; 5 20.539589_-89.341231_obs536411_2015 2015 2 #&gt; 6 20.539589_-89.341231_obs536411_2016 2016 3 Now that we have data suitable for occupancy modeling, we need to reformat the data to be accepted by unmarked. The documentation for the unmarked function formatWide() outlines the details of this format. In the EBD, each row is a checklist; however, unmarked requires each row to be a site with the first column specifying the site ID and subsequent columns specifying whether the species was observed on each of the visits to that site. The next group of columns contains site-level covariates, those that vary between sites but are constant across visits to the same site, such as latitude, longitude, and any habitat covariates we might have. Finally, the observation-level covariates, such as distance and duration, each get a set of columns corresponding to the the presence-absence columns. site_id y.1 y.2 y.3 latitude longitude forest_cover distance.1 distance.2 distance.3 time.1 time.2 time.3 site1 TRUE FALSE TRUE 20.2 182 0.12 14.51 10.01 12.41 33.7 43.5 20.7 site2 FALSE TRUE 20.6 183 0.45 9.84 11.90 26.4 23.8 site3 TRUE FALSE FALSE 19.9 182 0.98 8.95 12.63 9.78 23.4 30.1 13.3 site4 TRUE FALSE 21.0 183 0.23 10.26 6.00 31.9 26.9 site5 FALSE FALSE FALSE 29.8 183 0.43 11.34 7.58 16.88 24.8 25.0 23.6 The auk function format_unmarked_occu() takes care of the reformatting for you. The response argument defines the variable that you will be using as the response in occupancy modeling (e.g. observation_count or species_observered), site_covs are the site-level covariates, and obs_covs are the observation-level covariates. visits_um &lt;- format_unmarked_occu(visits, site_id = &quot;site&quot;, response = &quot;species_observed&quot;, site_covs = c(&quot;latitude&quot;, &quot;longitude&quot;), obs_covs = c(&quot;time_observations_started&quot;, &quot;duration_minutes&quot;, &quot;effort_distance_km&quot;, &quot;number_observers&quot;, &quot;protocol_type&quot;)) Exercise Explore both the visits_um and visits dataframes. They contain the same data in different formats. Try to understand how one dataframe was transformed into the other. 8.3 Reducing file size Even after filtering the EBD, somtimes it’s still too large to read into R and work with. There are several approaches for reducing the size of the EBD. We’ll cover three here: stricter filtering, removing columns, and splitting by species. 8.3.1 Stricter filtering The most obvious way to reduce the size of an EBD extract is to use stricter filters: focus on a smaller region, shorter time period, or fewer species. To avoid having to waste several hours trying to filter the entire EBD all over again, it’s worthwhile noting that you can always re-filter an EBD extract directly. So, if you realize you were too coarse in your initial filtering, apply the stricter filter to the EBD extract rather than the full EBD so save time. 8.3.2 Removing columns The EBD contains a lot of columns (46 to be precise), many of which are redundant or not useful in most scenarios. For example, country, state, and county each have two columns, one for the name and one for the code. Other columns, such as the Important Bird Area (IBA) that a checklist belong to and the checklist comments, are rarely useful. By removing these columns we can drastically reduce the size of the EBD. The available columns in the EBD are listed and defined in the PDF metadata that comes with the EBD (eBird_Basic_Dataset_Metadata_v1.12.pdf). Alternatively, there’s a useful trick to get a list of column names from an auk_ebd object. library(auk) ebd &lt;- auk_ebd(&quot;ebd_2015-2016_yucatan.txt&quot;) ebd$col_idx$name #&gt; [1] &quot;global unique identifier&quot; &quot;last edited date&quot; #&gt; [3] &quot;taxonomic order&quot; &quot;category&quot; #&gt; [5] &quot;common name&quot; &quot;scientific name&quot; #&gt; [7] &quot;subspecies common name&quot; &quot;subspecies scientific name&quot; #&gt; [9] &quot;observation count&quot; &quot;breeding bird atlas code&quot; #&gt; [11] &quot;breeding bird atlas category&quot; &quot;age sex&quot; #&gt; [13] &quot;country&quot; &quot;country code&quot; #&gt; [15] &quot;state&quot; &quot;state code&quot; #&gt; [17] &quot;county&quot; &quot;county code&quot; #&gt; [19] &quot;iba code&quot; &quot;bcr code&quot; #&gt; [21] &quot;usfws code&quot; &quot;atlas block&quot; #&gt; [23] &quot;locality&quot; &quot;locality id&quot; #&gt; [25] &quot;locality type&quot; &quot;latitude&quot; #&gt; [27] &quot;longitude&quot; &quot;observation date&quot; #&gt; [29] &quot;time observations started&quot; &quot;observer id&quot; #&gt; [31] &quot;sampling event identifier&quot; &quot;protocol type&quot; #&gt; [33] &quot;protocol code&quot; &quot;project code&quot; #&gt; [35] &quot;duration minutes&quot; &quot;effort distance km&quot; #&gt; [37] &quot;effort area ha&quot; &quot;number observers&quot; #&gt; [39] &quot;all species reported&quot; &quot;group identifier&quot; #&gt; [41] &quot;has media&quot; &quot;approved&quot; #&gt; [43] &quot;reviewed&quot; &quot;reason&quot; #&gt; [45] &quot;trip comments&quot; &quot;species comments&quot; The function auk_select() will process the EBD to only keep the selected columns. cols &lt;- c(&quot;latitude&quot;, &quot;longitude&quot;, &quot;group identifier&quot;, &quot;sampling event identifier&quot;, &quot;scientific name&quot;, &quot;observation count&quot;, &quot;observer_id&quot;) f_select &lt;- &quot;data/ebd_smaller.txt&quot; selected &lt;- auk_select(ebd, select = cols, file = f_select) %&gt;% read_ebd() names(selected) #&gt; [1] &quot;checklist_id&quot; &quot;scientific_name&quot; #&gt; [3] &quot;observation_count&quot; &quot;latitude&quot; #&gt; [5] &quot;longitude&quot; &quot;observer_id&quot; #&gt; [7] &quot;sampling_event_identifier&quot; &quot;group_identifier&quot; auk_select() is typically applied to a subset of the EBD to reduce the size before reading it into R. However, this function can also be applied to entire EBD to remove any columns that you’re sure you’ll never need. If you’re running out of hard drive space, this approach can drastically reduce the size of the EBD and free up space. Exercise Removing columns can also be done concurrently with filtering the EBD. Consult the documentation for auk_filter() and look at the keep and drop arguments. Use these to extract all Least Grebe records from Belize and remove the trip comments and species comments fields in addition to any other fields you feel aren’t required. Solution ebd_leagre &lt;- ebd %&gt;% auk_species(&quot;Least Grebe&quot;) %&gt;% auk_country(&quot;BZ&quot;) %&gt;% auk_filter(&quot;data/ebd_leagre.txt&quot;, drop = c(&quot;trip_comments&quot;, &quot;species_comments&quot;, &quot;country&quot;, &quot;state&quot;, &quot;county&quot;)) %&gt;% read_ebd() 8.3.3 Splitting by species If you’re working with a large number of species, the size of the EBD can quickly increase. An easy way to address this before importing data into R is to split the EBD extract up into seperate files, one for each species. You can then read in species one at a time and process them. Note that the Sampling Event Data doesn’t need to be split and the same file can be used for each species EBD file. The function auk_split() facilitates this process. You provide an EBD extract and a vector of species names and it will split the EBD up into species-specific files. In Lesson 7 we extracted eBird data for 3 warbler species, let’s use auk_split() to split this file up. split_species &lt;- c(&quot;Wilson&#39;s Warbler&quot;, &quot;Canada Warbler&quot;, &quot;Pink-headed Warbler&quot;) f_split &lt;- auk_split(&quot;data/ebd_cardellina.txt&quot;, species = split_species, prefix = &quot;data/ebd_split_&quot;) f_split #&gt; [1] &quot;data/ebd_split_Cardellina_pusilla.txt&quot; #&gt; [2] &quot;data/ebd_split_Cardellina_canadensis.txt&quot; #&gt; [3] &quot;data/ebd_split_Cardellina_versicolor.txt&quot; Next, let’s take the first of these files (for Wilson’s Warbler) and zero-fill it using the Sampling Event Data we extracted in Lesson 7. wilwar &lt;- auk_zerofill(f_split[1], sampling_events = &quot;data/sed_cardellina.txt&quot;, collapse = TRUE) When working with the full EBD, this approach is much faster because we only need to filter the EBD once instead of once for each species. This could be the difference between a few hours of processing time and a few days. 8.4 Land cover covariates To use eBird data for modeling species distributions you’ll typically want to attach habitat data to the checklists to use as model covariates. There are a wide variety of freely available, satellite-derived land use and land cover products available for use as covariates. The specific set of covariates you use, and the dataset that you derived them from, will depend on the specifics of your study: the focal species and region, and question you’re asking. However, we recommend the MODIS MCD12Q1 land cover dataset as a good general use source of land cover covariates. This product is global in extent, available annually since 2001, and provided in a raster format at 500 m resolution. The free eBird Best Practices book associated with this workshop covers in detail how to download land cover data and attach it to eBird checklists. However, we provide an overview of the process here. Download: download land cover data (e.g. MODIS MCD12Q1) for your region of interest, either manually or using the R package MODIS. These data will likely be downloaded in the form of multiple tiles that need to be combined together then converted to GeoTIFF format. This is done automatically if you’re using the MOIDS package, but it can be done manually using the command line tool GDAL. Summarize: birds use and respond to their environment at a scale that is typically larger than the resolution of the satellite data. Furthermore, there is uncertainty in the location of eBird checklists, particularly traveling checklists. So, you should usually summarize the data within a neighborhood of each checklist. This can be done most simply by calculating the percent of each landcover class within a neighborhood of each point. Prediction surface: once you’ve fit your models using the land cover covariates you generated in the previous steps, you’ll usually want to make predictions over the landscape and produce maps. This requires defining a regular grid of points at which you calculate the same summarized land cover covariates as you did in the previous step. To see the code for each of these steps consult the eBird Best Practices book. "]
]
